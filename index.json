[{"categories":["gitlab"],"content":"Gitlab批量导出用户 登陆Gitlab服务器进行数据库登陆、数据查询及信息导出操作。 ","date":"2022-01-14","objectID":"/exportuser/:0:0","tags":["自动化"],"title":"Gitlab批量导出用户","uri":"/exportuser/"},{"categories":["gitlab"],"content":"操作步骤 根据配置文件，定位数据库相关信息 cat /var/opt/gitlab/gitlab-rails/etc/database.yml 查看Gitlab对应的系统用户 cat /etc/passwd | grep gitlab 切换用户gitlab-psql su - gitlab-psql 登陆数据库（-h指定host，-d指定数据库） 使用第1步获取的信息 psql -h /var/opt/gitlab/postgresql -d gitlabhq_production (1) 查看帮助信息 gitlabhq_production=# \\h (2) 查看数据库 gitlabhq_production=# \\l (3) 查看库中的表（执行命令后，按回车键显示更多表信息） gitlabhq_production=# \\dt (4) 通过筛查，可在库中找到users表，相关用户信息都记录在表中！ gitlabhq_production=# \\d users (5) 查看表信息 gitlabhq_production=# SELECT * FROM users; (6) 查看users表中的name字段 gitlabhq_production=# SELECT name FROM users; (7)登出数据库 gitlabhq_production=# \\q 根据需要提取的信息，确定表users中的字段，进行导出操作 echo 'select name,username,email,state from users;' |psql -h /var/opt/gitlab/postgresql -d gitlabhq_production \u003e userinfo.txt 存储在/var/opt/gitlab/postgresql/userinfo.txt ","date":"2022-01-14","objectID":"/exportuser/:1:0","tags":["自动化"],"title":"Gitlab批量导出用户","uri":"/exportuser/"},{"categories":["k8s"],"content":"Harbor 搭建 Harbor 是一个开源可信的云原生注册表项目，用于存储、签名和扫描内容。用于存储docker image ","date":"2022-01-14","objectID":"/harbor/:0:0","tags":["k8s"],"title":"Harbor 搭建","uri":"/harbor/"},{"categories":["k8s"],"content":"要求 Linux主机 docker 17.06.0-ce 以上 docker-compose 1.18.0 以上 链接跳转：docker 安装 ","date":"2022-01-14","objectID":"/harbor/:1:0","tags":["k8s"],"title":"Harbor 搭建","uri":"/harbor/"},{"categories":["k8s"],"content":"安装 下载程序 在线安装包 wget https://github.com/goharbor/harbor/releases/download/v1.10.10/harbor-online-installer-v1.10.10.tgz 离线安装包 wget https://github.com/goharbor/harbor/releases/download/v1.10.10/harbor-offline-installer-v1.10.10.tgz 安装 mkdir -p /data cd /data tar -zxvf harbor-offline-installer-v1.10.10.tgz cd /harbor ./install.sh 接下来只要安静的等待安装就可以了 ","date":"2022-01-14","objectID":"/harbor/:2:0","tags":["k8s"],"title":"Harbor 搭建","uri":"/harbor/"},{"categories":["k8s"],"content":"配置 # Configuration file of Harbor# The IP address or hostname to access admin UI and registry service.# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.hostname:\u003c域名\u003e# http related confighttp:# port for http, default is 80. If https enabled, this port will redirect to https portport:80# https related confighttps:# https port for harbor, default is 443port:443# SSL证书certificate:/hub/ssl/bundle.pemprivate_key:/hub/ssl/key# Uncomment external_url if you want to enable external proxy# And when it enabled the hostname will no longer used# external_url: https://reg.mydomain.com:8433# The initial password of Harbor admin# It only works in first time to install harbor# Remember Change the admin password from UI after launching Harbor.harbor_admin_password:\u003c密码\u003e# Harbor DB configurationdatabase:# The password for the root user of Harbor DB. Change this before any production use.password:\u003c密码\u003e# The maximum number of connections in the idle connection pool. If it \u003c=0, no idle connections are retained.max_idle_conns:50# The maximum number of open connections to the database. If it \u003c= 0, then there is no limit on the number of open connections.# Note: the default number of connections is 100 for postgres.max_open_conns:100# The default data volumedata_volume:/data# Harbor Storage settings by default is using /data dir on local filesystem# Uncomment storage_service setting If you want to using external storage# storage_service:# # ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore# # of registry's and chart repository's containers. This is usually needed when the user hosts a internal storage with self signed certificate.# ca_bundle:# # storage backend, default is filesystem, options include filesystem, azure, gcs, s3, swift and oss# # for more info about this configuration please refer https://docs.docker.com/registry/configuration/# filesystem:# maxthreads: 100# # set disable to true when you want to disable registry redirect# redirect:# disabled: false# Clair configurationclair:# The interval of clair updaters, the unit is hour, set to 0 to disable the updaters.updaters_interval:12jobservice:# Maximum number of job workers in job servicemax_job_workers:10notification:# Maximum retry count for webhook jobwebhook_job_max_retry:10chart:# Change the value of absolute_url to enabled can enable absolute url in chartabsolute_url:disabled# Log configurationslog:# options are debug, info, warning, error, fatallevel:info# configs for logs in local storagelocal:# Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.rotate_count:50# Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.# If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G# are all valid.rotate_size:200M# The directory on your host that store loglocation:/var/log/harbor# Uncomment following lines to enable external syslog endpoint.# external_endpoint:# # protocol used to transmit log to external endpoint, options is tcp or udp# protocol: tcp# # The host of external endpoint# host: localhost# # Port of external endpoint# port: 5140#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!_version:1.10.0# Uncomment external_database if using external database.# external_database:# harbor:# host: harbor_db_host# port: harbor_db_port# db_name: harbor_db_name# username: harbor_db_username# password: harbor_db_password# ssl_mode: disable# max_idle_conns: 2# max_open_conns: 0# clair:# host: clair_db_host# port: clair_db_port# db_name: clair_db_name# username: clair_db_username# password: clair_db_password# ssl_mode: disable# notary_signer:# host: notary_signer_db_host# port: notary_signer_db_port# db_name: notary_signer_db_name# usernam","date":"2022-01-14","objectID":"/harbor/:3:0","tags":["k8s"],"title":"Harbor 搭建","uri":"/harbor/"},{"categories":["监控"],"content":"prometheus+grafana+alertmanager 安装配置 服务器监控告警系统搭建，通过exporter获取节点信息到prometheus。prometheus配置规则，使garfana和alertmanager能够接受到数据，分别展示数据和发送告警 ","date":"2022-01-13","objectID":"/prometheus1/:0:0","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"参数 VM :192.168.99.78 端口 服务 9100 node_exporter 3000 grafana 9090 prometheus 9115 blackbox_exporter ","date":"2022-01-13","objectID":"/prometheus1/:1:0","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"安装 ","date":"2022-01-13","objectID":"/prometheus1/:2:0","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"grafa安装 docker安装 docker run -d -p 3000:3000 \\ --name=grafana \\ -v grafana-storage:/var/lib/grafana \\ grafana/grafana:8.3.3 ","date":"2022-01-13","objectID":"/prometheus1/:2:1","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"prometheus 安装 下载 wget https://github.com/prometheus/prometheus/releases/download/v2.32.1/prometheus-2.32.1.linux-amd64.tar.gz tar -zxvf prometheus-2.32.1.linux-amd64.tar.gz cd prometheus-2.32.1.linux-amd64 mkdir -p file_sd mkdir -p rules 运行 prometheus killall prometheus nohup ./prometheus --config.file=prometheus.yml \u0026 # 查看运行状况 tail -f nohup.out ","date":"2022-01-13","objectID":"/prometheus1/:2:2","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"node_exporter 安装 docker-compose 安装 version:\"3\"services:node-exporter:image:prom/node-exporter:v1.3.1container_name:node-exporterrestart:alwaysports:- \"9100:9100\" docker-compose up -d 二进制安装 wget https://github.com/prometheus/node_exporter/releases/download/v1.3.1/node_exporter-1.3.1.linux-amd64.tar.gz tar -zxvf node_exporter-1.3.1.linux-amd64.tar.gz cd node_exporter-1.3.1.linux-amd64 nohup ./node_exporter \u0026 ","date":"2022-01-13","objectID":"/prometheus1/:2:3","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"blackbox_exporter 二进制安装 wget https://github.com/prometheus/blackbox_exporter/releases/download/v0.19.0/blackbox_exporter-0.19.0.linux-amd64.tar.gz tar -zxvf blackbox_exporter-0.19.0.linux-amd64.tar.gz cd blackbox_exporter-0.19.0.linux-amd64 nohup ./blackbox_exporter \u0026 ","date":"2022-01-13","objectID":"/prometheus1/:2:4","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"Alertmanager 二进制安装 wget https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager-0.23.0.linux-amd64.tar.gz tar -zxvf alertmanager-0.23.0.linux-amd64.tar.gz cd alertmanager-0.23.0.linux-amd64 nohup ./alertmanager \u0026 docker-compose 安装 version:\"3\"services:alertmanager:image:\"prom/alertmanager:v0.22.2\"volumes:- \"/etc/localtime:/etc/localtime\"- \"./alertmanager.yml:/etc/alertmanager/alertmanager.yml\"ports:- \"9093:9093\"restart:\"always\"container_name:\"alertmanager\" ","date":"2022-01-13","objectID":"/prometheus1/:2:5","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"prometheus.yml 配置 global:scrape_interval:15s# By default, scrape targets every 15 seconds.# Attach these labels to any time series or alerts when communicating with# external systems (federation, remote storage, Alertmanager).external_labels:monitor:'codelab-monitor'# Alertmanager configuration# alerting:# alertmanagers:# - static_configs:# - targets:# - 192.168.99.78:9093# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.# rule_files:# - \"./rules/blackbox.yaml\"# - \"./rules/node-exporter.yaml\"# A scrape configuration containing exactly one endpoint to scrape:# Here it's Prometheus itself.scrape_configs:# The job name is added as a label `job=\u003cjob_name\u003e` to any timeseries scraped from this config.- job_name:'prometheus'# Override the global default and scrape targets from this job every 5 seconds.scrape_interval:5sstatic_configs:- targets:['localhost:9090']- job_name:'node-exporter'file_sd_configs:- files:- \"./file_sd/node-exporter.yaml\"refresh_interval:5s- job_name:'blackbox'metrics_path:/probescrape_interval:30sscrape_timeout:30sparams:module:[http_2xx] # Look for a HTTP 200 response.file_sd_configs:- files:- \"./file_sd/blackbox.yaml\"refresh_interval:5srelabel_configs:- source_labels:[__address__]target_label:__param_target- source_labels:[__param_target]target_label:instance- target_label:__address__replacement:192.168.99.78:9115 ","date":"2022-01-13","objectID":"/prometheus1/:3:0","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"node-exporter.yaml - targets:['192.168.99.78:9100']labels:instance:\u003c实例名称\u003e- targets:['\u003cIP\u003e:9100']labels:instance:实例名称 ","date":"2022-01-13","objectID":"/prometheus1/:3:1","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"blackbox.yaml - targets:- https://www.jobcher.com- https://\u003c域名\u003e ","date":"2022-01-13","objectID":"/prometheus1/:3:2","tags":["prometheus"],"title":"prometheus grafana alertmanager 安装配置","uri":"/prometheus1/"},{"categories":["监控"],"content":"prometheus 配置 Prometheus 是由 SoundCloud 开源监控告警解决方案 ","date":"2022-01-13","objectID":"/prometheus/:0:0","tags":["prometheus"],"title":"prometheus 配置","uri":"/prometheus/"},{"categories":["监控"],"content":"组件 Prometheus Server， 主要用于抓取数据和存储时序数据，另外还提供查询和 Alert Rule 配置管理。 client libraries，用于对接 Prometheus Server, 可以查询和上报数据。 push gateway ，用于批量，短期的监控数据的汇总节点，主要用于业务数据汇报等。 各种汇报数据的 exporters ，例如汇报机器数据的 node_exporter, 汇报 MongoDB 信息的 MongoDB exporter 等等。 用于告警通知管理的 alertmanager 。 ","date":"2022-01-13","objectID":"/prometheus/:1:0","tags":["prometheus"],"title":"prometheus 配置","uri":"/prometheus/"},{"categories":["监控"],"content":"运行逻辑 Prometheus server 定期从静态配置的 targets 或者服务发现的 targets 拉取数据。 当新拉取的数据大于配置内存缓存区的时候，Prometheus 会将数据持久化到磁盘（如果使用 remote storage 将持久化到云端）。 Prometheus 可以配置 rules，然后定时查询数据，当条件触发的时候，会将 alert 推送到配置的 Alertmanager。 Alertmanager 收到警告的时候，可以根据配置，聚合，去重，降噪，最后发送警告。 可以使用 API， Prometheus Console 或者 Grafana 查询和聚合数据。 ","date":"2022-01-13","objectID":"/prometheus/:2:0","tags":["prometheus"],"title":"prometheus 配置","uri":"/prometheus/"},{"categories":["监控"],"content":"安装prometheus 使用预编译的二进制文件安装 wget https://github.com/prometheus/prometheus/releases/download/v2.32.1/prometheus-2.32.1.linux-amd64.tar.gz tar -zxvf prometheus-2.32.1.linux-amd64.tar.gz cd prometheus-2.32.1.linux-amd64 使用docker 安装 mkdir -p opt/prometheus vim prometheus.yml docker run \\ -p 9090:9090 \\ -v /path/to/prometheus.yml:/opt/prometheus/prometheus.yml \\ prom/prometheus ","date":"2022-01-13","objectID":"/prometheus/:3:0","tags":["prometheus"],"title":"prometheus 配置","uri":"/prometheus/"},{"categories":["日常"],"content":"centos7.9 网络配置 解决centos 新机器网络不通的问题，CentOS7默认不启动网卡的。CentOS 安装成功后,进行一下 ping 的操作,验证网络是否联通. ping 1.1.1.1 ip addr # 查看ip网络名称 启用网卡 进入 /etc/sysconfig/network-scipts 文件夹下，找到IP网卡名称 cd /etc/sysconfig/network-scipts vim ifcfg-eth0 启用 ONBOOT #vim ifcfg-eth0 #修改 ONBOOT=YES # esc 并:wq退出保存 重启机器 shutdown -r now ","date":"2022-01-11","objectID":"/linux-network/:0:0","tags":["linux"],"title":"centos7.9 网络配置","uri":"/linux-network/"},{"categories":["日常"],"content":"结尾 centos用的挺别扭，不考虑性能和性价比，我还是喜欢用ubuntu……，简单的配置，初学者我建议还是先用ubuntu，会少踩很多坑。当然了，用x86不然初学者用树莓派和arm设备，会碰到很多兼容性的问题。 ","date":"2022-01-11","objectID":"/linux-network/:1:0","tags":["linux"],"title":"centos7.9 网络配置","uri":"/linux-network/"},{"categories":["问题库"],"content":"安装 docker 出现 ERROR: Unsupported distribution ‘ol’ 问题 部署docker 安装出现 ERROR: Unsupported distribution ‘ol’ 确认是不是arm架构 uname -r 确认使用的是不是oracle服务器系统,如果是请继续操作，安装依赖： dnf install -y dnf-utils zip unzip dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo 安装docker dnf remove -y runc dnf install -y docker-ce --nobest 完成docker 安装并检查 systemctl enable docker.service systemctl start docker.service #检查 systemctl status docker.service docker info docker version ","date":"2022-01-11","objectID":"/error1/:0:0","tags":["error"],"title":"安装 docker 出现 ERROR: Unsupported distribution 'ol' 问题","uri":"/error1/"},{"categories":["问题库"],"content":"结尾 该问题主要是oracle没有支持依赖导致的~oracle还是很不错的~ ","date":"2022-01-11","objectID":"/error1/:1:0","tags":["error"],"title":"安装 docker 出现 ERROR: Unsupported distribution 'ol' 问题","uri":"/error1/"},{"categories":["k8s"],"content":"Kubernetes 实验手册（1） 通过在pve创建5台虚拟机： 节点 IP 作用 node0 192.168.99.69 k8s-master01 node1 192.168.99.9 k8s-master02 node2 192.168.99.53 k8s-master03 node3 192.168.99.41 k8s-node01 node4 192.168.99.219 k8s-node02 node5 192.168.99.42 k8s-master-lb 配置信息 备注 系统版本 Ubuntu Docker 20.10.12 pod网段 172.168.0.0/12 service网段 10.96.0.0/12 VIP 不要和内网IP重复，VIP需要和主机在同一个局域网内 更新ansible连接 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.99.155 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.99.199 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.99.87 #ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.99.41 #ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.99.219 vim /etc/hosts 192.168.99.155 k8s-master01 192.168.99.199 k8s-master02 192.168.99.87 k8s-master03 #192.168.99.41 k8s-node01 #192.168.99.219 k8s-node02 ","date":"2022-01-07","objectID":"/k8s1/:0:0","tags":["k8s"],"title":"Kubernetes 实验手册（1）","uri":"/k8s1/"},{"categories":["k8s"],"content":"基本配置 安装基本软件包 apt install wget jq psmisc vim net-tools telnet lvm2 git -y # 关闭swap分区 vim /etc/fstab 注释掉swap 内容 并重启 reboot # 时间同步 apt install ntpdate -y # 查看时区 timedatectl set-timezone 'Asia/Shanghai' timedatectl date 安装docker curl -sSL https://get.daocloud.io/docker | sh systemctl restart docker 安装k8s组件 # 更新 apt 包索引并安装使用 Kubernetes sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl # 下载 Google Cloud 公开签名秘钥： sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg # 添加 Kubernetes apt 仓库 echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list # 更新 apt 包索引，安装 kubelet、kubeadm 和 kubectl，并锁定其版本： sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl sudo apt-mark hold kubelet kubeadm kubectl 安装keepalived和haproxy 所有Master节点安装HAProxy和KeepAlived apt install keepalived haproxy -y cp -rf /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak rm -rf /etc/haproxy/haproxy.cfg vim /etc/haproxy/haproxy.cfg 所有Master节点的HAProxy配置相同 global maxconn 2000 ulimit-n 16384 log 127.0.0.1 local0 err stats timeout 30s defaults log global mode http option httplog timeout connect 5000 timeout client 50000 timeout server 50000 timeout http-request 15s timeout http-keep-alive 15s frontend monitor-in bind *:33305 mode http option httplog monitor-uri /monitor frontend k8s-master bind 0.0.0.0:16443 bind 127.0.0.1:16443 mode tcp option tcplog tcp-request inspect-delay 5s default_backend k8s-master backend k8s-master mode tcp option tcplog option tcp-check balance roundrobin default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100 server k8s-master01 192.168.99.155:6443 check server k8s-master02 192.168.99.199:6443 check server k8s-master03 192.168.99.87:6443 check 所有Master节点配置KeepAlived，配置不一样，注意区分 注意每个节点的IP和网卡（interface参数） vim /etc/keepalived/keepalived.conf ! Configuration File for keepalived global_defs { router_id LVS_DEVEL script_user root enable_script_security } vrrp_script chk_apiserver { script \"/etc/keepalived/check_apiserver.sh\" interval 5 weight -5 fall 2 rise 1 } vrrp_instance VI_1 { state MASTER interface ens18 #查看网关地址 mcast_src_ip 192.168.99.155 #本机IP virtual_router_id 51 priority 101 advert_int 2 authentication { auth_type PASS auth_pass K8SHA_KA_AUTH } virtual_ipaddress { 192.168.99.42 # vip地址 } # track_script { # chk_apiserver # } } 配置KeepAlived健康检查文件 vim /etc/keepalived/check_apiserver.sh #!/bin/bash err=0 for k in $(seq 1 3) do check_code=$(pgrep haproxy) if [[ $check_code == \"\" ]]; then err=$(expr $err + 1) sleep 1 continue else err=0 break fi done if [[ $err != \"0\" ]]; then echo \"systemctl stop keepalived\" /usr/bin/systemctl stop keepalived exit 1 else exit 0 fi chmod +x /etc/keepalived/check_apiserver.sh systemctl restart haproxy.service systemctl restart keepalived.service apt install kubeadm -y ","date":"2022-01-07","objectID":"/k8s1/:1:0","tags":["k8s"],"title":"Kubernetes 实验手册（1）","uri":"/k8s1/"},{"categories":["k8s"],"content":"集群初始化 Master01节点创建new.yaml配置文件如下： mkdir -p k8s \u0026\u0026 cd k8s vim new.yaml apiVersion:kubeadm.k8s.io/v1beta2bootstrapTokens:- groups:- system:bootstrappers:kubeadm:default-node-tokentoken:7t2weq.bjbawausm0jaxuryttl:24h0m0susages:- signing- authenticationkind:InitConfigurationlocalAPIEndpoint:advertiseAddress:192.168.99.155bindPort:6443nodeRegistration:criSocket:/var/run/dockershim.sockname:k8s-master01taints:- effect:NoSchedulekey:node-role.kubernetes.io/master---apiServer:certSANs:- 192.168.99.42timeoutForControlPlane:4m0sapiVersion:kubeadm.k8s.io/v1beta2certificatesDir:/etc/kubernetes/pkiclusterName:kubernetescontrolPlaneEndpoint:192.168.99.42:16443controllerManager:{}dns:type:CoreDNSetcd:local:dataDir:/var/lib/etcdimageRepository:registry.cn-hangzhou.aliyuncs.com/google_containerskind:ClusterConfigurationkubernetesVersion:v1.23.1networking:dnsDomain:cluster.localpodSubnet:172.168.0.0/16serviceSubnet:10.96.0.0/12scheduler:{} kubeadm config images pull --config /root/k8s/new.yaml master01 节点生成初始化,初始化以后会在/etc/kubernetes目录下生成对应的证书和配置文件，之后其他Master节点加入Master01即可 systemctl enable --now kubelet kubeadm init --config /root/k8s/new.yaml --upload-certs 初始化成功以后，会产生Token值，用于其他节点加入时使用，因此要记录下初始化成功生成的token值（令牌值）： ","date":"2022-01-07","objectID":"/k8s1/:2:0","tags":["k8s"],"title":"Kubernetes 实验手册（1）","uri":"/k8s1/"},{"categories":["日常"],"content":"RocketMQ 安装和部署 部署RocketMQ ","date":"2022-01-07","objectID":"/rocketmq/:0:0","tags":["RocketMQ"],"title":"RocketMQ 安装和启动","uri":"/rocketmq/"},{"categories":["日常"],"content":"单机安装构建 安装JDK 1.8.0 yum install java-1.8.0-openjdk* 安装Maven wget http://dlcdn.apache.org/maven/maven-3/3.8.4/binaries/apache-maven-3.8.4-bin.tar.gz tar -zxvf apache-maven-3.8.4-bin.tar.gz mv -f apache-maven-3.8.4 /usr/local/ vim /etc/profile # 末尾添加 export MAVEN_HOME=/usr/local/apache-maven-3.8.4 export PATH=${PATH}:${MAVEN_HOME}/bin # 保存 source /etc/profile # 查看maven是否正常 mvn -v ","date":"2022-01-07","objectID":"/rocketmq/:1:0","tags":["RocketMQ"],"title":"RocketMQ 安装和启动","uri":"/rocketmq/"},{"categories":["日常"],"content":"快速部署 #构建 DLedger git clone https://github.com/openmessaging/openmessaging-storage-dledger.git cd openmessaging-storage-dledger mvn clean install -DskipTests # 构建 RocketMQ git clone https://github.com/apache/rocketmq.git cd rocketmq git checkout -b store_with_dledger origin/store_with_dledger mvn -Prelease-all -DskipTests clean install -U # 部署 cd rocketmq/distribution/target/apache-rocketmq sh bin/dledger/fast-try.sh start # 通过 mqadmin 运维命令查看集群状态 sh bin/mqadmin clusterList -n 127.0.0.1:9876 启动单节点 cd distribution/target/rocketmq-4.9.3-SNAPSHOT/rocketmq-4.9.3-SNAPSHOT nohup sh bin/mqnamesrv \u0026 # 查看 Namesrv 日志 tail -f ~/logs/rocketmqlogs/namesrv.log 2022-01-07 14:59:29 INFO main - The Name Server boot success. serializeType=JSON # 启动 Broker nohup sh bin/mqbroker -c conf/broker.conf -n 127.0.0.1:9876 \u0026 # 查看 Broker 日志 tail -f ~/logs/rocketmqlogs/broker.log 如果提示找不到上面的日志文件，应该是没启动成功。 应该是内存不够，RocketMQ默认用8g内存，如果你服务器的内存比较小，可以修改下bin/runbroker.sh脚本，将 Broker JVM 内存调小。如：JAVA_OPT=\"${JAVA_OPT} -server -Xms2g -Xmx2g -Xmn1g\"。 再次启动broker，可以正常启动。 默认情况下，Broker 日志文件所在地址为~/logs/rocketmqlogs/broker.log。如果想要自定义，可以通过conf/logback_broker.xml配置文件来进行修改。 ","date":"2022-01-07","objectID":"/rocketmq/:2:0","tags":["RocketMQ"],"title":"RocketMQ 安装和启动","uri":"/rocketmq/"},{"categories":["日常"],"content":"安装 minIO ","date":"2022-01-07","objectID":"/minio/:0:0","tags":["minIO"],"title":"安装 minIO Azure S3网关","uri":"/minio/"},{"categories":["日常"],"content":"通过docker 安装 docker run -p 9000:9000 -p 41863:41863 -d --name azure-s3 \\ -e \"MINIO_ACCESS_KEY=azure存储账户\" \\ -e \"MINIO_SECRET_KEY=azure存储密码\" \\ minio/minio gateway azure --console-address \":41863\" ","date":"2022-01-07","objectID":"/minio/:1:0","tags":["minIO"],"title":"安装 minIO Azure S3网关","uri":"/minio/"},{"categories":["日常"],"content":"通过docker-compose 安装 version:\"3\"services:minio:image:\"minio/minio:RELEASE.2022-01-04T07-41-07Z.fips\"container_name:\"minio\"restart:\"always\"volumes:- \"/etc/localtime:/etc/localtime\"ports:- \"9000:9000\"- \"9001:9001\"environment:- \"MINIO_ROOT_USER=azure存储账户\"- \"MINIO_ROOT_PASSWORD=azure存储密码\"command:- --console-address \":41863\" ","date":"2022-01-07","objectID":"/minio/:2:0","tags":["minIO"],"title":"安装 minIO Azure S3网关","uri":"/minio/"},{"categories":["k8s"],"content":"Keepalived高可用 配置文件存放位置：/usr/share/doc/keepalived/samples VVRP 虚拟路由冗余协议 ","date":"2022-01-05","objectID":"/keepalived/:0:0","tags":["k8s"],"title":"Keepalived高可用","uri":"/keepalived/"},{"categories":["k8s"],"content":"组成 LB集群：Load Balancing，负载均衡集群，平均分配给多个节点 HA集群：High Availability，高可用集群，保证服务可用 HPC集群：High Performance Computing，高性能集群 ","date":"2022-01-05","objectID":"/keepalived/:1:0","tags":["k8s"],"title":"Keepalived高可用","uri":"/keepalived/"},{"categories":["k8s"],"content":"配置 keepalived+LVS+nginx 各节点时间必须同步：ntp, chrony 关闭防火墙及SELinux ","date":"2022-01-05","objectID":"/keepalived/:2:0","tags":["k8s"],"title":"Keepalived高可用","uri":"/keepalived/"},{"categories":["k8s"],"content":"同步各节点时间 #安装ntpdate apt install ntpdate #更改时区 timedatectl set-timezone 'Asia/Shanghai' #查看时间 timedatectl datetime ","date":"2022-01-05","objectID":"/keepalived/:2:1","tags":["k8s"],"title":"Keepalived高可用","uri":"/keepalived/"},{"categories":["k8s"],"content":"安装keepalived #安装 apt install keepalived #更改模板 cd /usr/share/doc/keepalived/samples ","date":"2022-01-05","objectID":"/keepalived/:2:2","tags":["k8s"],"title":"Keepalived高可用","uri":"/keepalived/"},{"categories":["gitlab"],"content":"ansible 安装和部署 Ansible默认通过 SSH 协议管理机器. ","date":"2021-12-30","objectID":"/ansible/:0:0","tags":["ansible"],"title":"ansible 安装和部署","uri":"/ansible/"},{"categories":["gitlab"],"content":"安装ansible 下载安装 # ubuntu 安装 apt-get install software-properties-common apt-add-repository ppa:ansible/ansible apt-get update apt-get install ansible # centos 安装 yum install ansible 检查文件 #检查 ansible --version ","date":"2021-12-30","objectID":"/ansible/:1:0","tags":["ansible"],"title":"ansible 安装和部署","uri":"/ansible/"},{"categories":["gitlab"],"content":"ansible 配置 添加主机 vim /etc/ansible/hosts #添加你需要添加的被控主机地址和IP 配置SSH key授权访问 # 控制主机生成ssh 密钥对（一路回车） ssh-keygen -t rsa # 复制公钥IP到被控主机 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.2 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.3 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.0.4 # ssh-copy-id命令会自动将id_rsa.pub文件的内容追加到远程主机root用户下.ssh/authorized_keys文件中。 更改ansible 配置 vim /etc/ansible/ansible.cfg #禁用每次执行ansbile命令检查ssh key host host_key_checking = False # 开启日志记录 log_path = /var/log/ansible.log 测试 # 控制主机 ansible all -m ping ","date":"2021-12-30","objectID":"/ansible/:2:0","tags":["ansible"],"title":"ansible 安装和部署","uri":"/ansible/"},{"categories":["gitlab"],"content":"Inventory 配置组别 vim /etc/ansible/hosts # 添加组别 [pve] 192.168.0.2 192.168.0.3 192.168.0.4 #测试 ansible pve -m ping Inventory 参数 把你的 inventory 文件 和 变量 放入 git repo 中,以便跟踪他们的更新,这是一种非常推荐的方式. 参数 作用 ansible_ssh_host 将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置. ansible_ssh_port ssh端口号.如果不是默认的端口号,通过此变量设置. ansible_ssh_user 默认的 ssh 用户名 ansible_ssh_pass ssh 密码(这种方式并不安全,我们强烈建议使用 –ask-pass 或 SSH 密钥) ansible_sudo_pass sudo 密码(这种方式并不安全,我们强烈建议使用 –ask-sudo-pass) ansible_sudo_exe (new in version 1.8) sudo 命令路径(适用于1.8及以上版本) ansible_connection 与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 ‘smart’,‘smart’ 方式会根据是否支持 ControlPersist, 来判断’ssh' 方式是否可行. ansible_ssh_private_key_file ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况. ansible_shell_type 目标系统的shell类型.默认情况下,命令的执行使用 ‘sh’ 语法,可设置为 ‘csh’ 或 ‘fish’. ansible_python_interpreter 目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是\"/usr/bin/python\",比如 *BSD, 或者 /usr/bin/python ","date":"2021-12-30","objectID":"/ansible/:3:0","tags":["ansible"],"title":"ansible 安装和部署","uri":"/ansible/"},{"categories":["基础"],"content":"yaml 语法 我们使用 YAML 是因为它像 XML 或 JSON 是一种利于人们读写的数据格式. 此外在大多数变成语言中有使用 YAML 的库.YAML 语法的基本概述, 它被用来描述一个 playbooks(我们的配置管理语言). 基本的 YAML 对于 Ansible, 每一个 YAML 文件都是从一个列表开始. 列表中的每一项都是一个键值对, 通常它们被称为一个 “哈希” 或 “字典”. 所以, 我们需要知道如何在 YAML 中编写列表和字典. YAML 还有一个小的怪癖. 所有的 YAML 文件(无论和 Ansible 有没有关系)开始行都应该是 —. 这是 YAML 格式的一部分, 表明一个文件的开始. ---# 一个美味水果的列表- Apple- Orange- Strawberry- Mango ","date":"2021-12-30","objectID":"/yaml/:0:0","tags":["运维"],"title":"yaml 语法","uri":"/yaml/"},{"categories":["基础"],"content":"linux 基础知识 ","date":"2021-12-29","objectID":"/linux/:0:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"1、简述Linux权限划分原则。 给文件或目录分配权限时，先考虑所有者和所属组 遵循最小化权限，用啥权限给啥权限 修改目录和子文件归属权限，注意递归 文件权限分配是最常用的安全防护手段 ","date":"2021-12-29","objectID":"/linux/:1:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"2、当用户user1，对/testdir目录有写和执行权限时，该目录下的只读文件file1是否可修改和删除？ ","date":"2021-12-29","objectID":"/linux/:2:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"3、如果一个系统没有任何的备份策略，请写出一个较为全面合理的备份方案！ ","date":"2021-12-29","objectID":"/linux/:3:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"4、网站服务器每天产生的日志数量较大，请问如何备份? 使用logrotate滚动日志 split大文件切分处理 shell脚本处理日志 ","date":"2021-12-29","objectID":"/linux/:4:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"5、简述Raid 0、Raid 1、Raid 5的特点与原理。 ","date":"2021-12-29","objectID":"/linux/:5:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"6、简述Raid6、Raid 10的特点与原理。 ","date":"2021-12-29","objectID":"/linux/:6:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"7、软Raid与硬Raid的区别？ ","date":"2021-12-29","objectID":"/linux/:7:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"8、Linux中有许多系统资源需要监管，请问有哪些命令可以查看？ ","date":"2021-12-29","objectID":"/linux/:8:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"9、简述CentOS 6.x的启动过程？ ","date":"2021-12-29","objectID":"/linux/:9:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"10、简述CentOS 7.x的启动过程？ ","date":"2021-12-29","objectID":"/linux/:10:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"11、如何进行Linux系统优化？ ","date":"2021-12-29","objectID":"/linux/:11:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["基础"],"content":"12、大文件如何删除？ 查看磁盘使用情况，查看是否需要扩容 df -h 查找大文件，使用du定位大文件位置 # 在根目录查找，展示第一层级的目录和文件，倒叙排列 ，展示前10名 du -h / --max-depth=1 | sort -hr | head -n 10 删除文件 # 删除文件可以直接用rm -rf 删除 rm -rf \u003c文件或目录\u003e # 按时间和名称删除 :找到目录下，超过10天的文件 删除名字后缀为.gz的文件 find /目录/* -mtime +10 -name \"*.gz\" -exec rm -rf {} \\ ","date":"2021-12-29","objectID":"/linux/:12:0","tags":["运维"],"title":"linux基础知识","uri":"/linux/"},{"categories":["日常"],"content":"logrotate 日志滚动的使用 logrotate 日志滚动切割工具，是linux默认安装的工具，配置文件位置： /etc/logrotate.conf /etc/logrotate.d/ ","date":"2021-12-29","objectID":"/logrotate/:0:0","tags":["daliy"],"title":"logrotate 日志滚动的使用","uri":"/logrotate/"},{"categories":["日常"],"content":"参数 以nginx 配置为例 /opt/log/nginx/*.log { daily missingok rotate 14 errors \"nb@nbtyfood.com\" compress delaycompress notifempty create 0640 www-data adm sharedscripts prerotate if [ -d /etc/logrotate.d/httpd-prerotate ]; then \\ run-parts /etc/logrotate.d/httpd-prerotate; \\ fi \\ endscript postrotate invoke-rc.d nginx rotate \u003e/dev/null 2\u003e\u00261 endscript } 参数 作用 compress 压缩日志文件的所有非当前版本 daily,weekly,monthly 按指定计划轮换日志文件 delaycompress 压缩所有版本，除了当前和下一个最近的 endscript 标记 prerotate 或 postrotate 脚本的结束 errors “emailid” 给指定邮箱发送错误通知 missingok 如果日志文件丢失，不要显示错误 notifempty 如果日志文件为空，则不轮换日志文件 olddir “dir” 指定日志文件的旧版本放在 “dir” 中 postrotate 引入一个在日志被轮换后执行的脚本 prerotate 引入一个在日志被轮换前执行的脚本 rotate ‘n’ 在轮换方案中包含日志的 n 个版本 sharedscripts 对于整个日志组只运行一次脚本 size=‘logsize’ 在日志大小大于 logsize（例如 100K，4M）时轮换 ","date":"2021-12-29","objectID":"/logrotate/:1:0","tags":["daliy"],"title":"logrotate 日志滚动的使用","uri":"/logrotate/"},{"categories":["docker"],"content":"安装docker 通过docker 脚本安装 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun curl -sSL https://get.daocloud.io/docker | sh ","date":"2021-12-28","objectID":"/docker/:0:0","tags":["docker"],"title":"docker 命令","uri":"/docker/"},{"categories":["docker"],"content":"docker-compose 安装 #下载安装 sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose #可执行权限 sudo chmod +x /usr/local/bin/docker-compose #创建软链： sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose #测试是否安装成功 docker-compose --version ","date":"2021-12-28","objectID":"/docker/:1:0","tags":["docker"],"title":"docker 命令","uri":"/docker/"},{"categories":["docker"],"content":"docker命令 常用docker命令 #查看容器 docker ps #查看镜像 docker images #停止当前所有容器 docker stop $(docker ps -aq) #删除当前停止的所有容器 docker rm $(docker ps -aq) #删除镜像 docker rmi nginx ","date":"2021-12-28","objectID":"/docker/:2:0","tags":["docker"],"title":"docker 命令","uri":"/docker/"},{"categories":["gitlab"],"content":"gitlab与github同步项目 本地同步项目 git clone 创建一个同名的项目,命令行终端中添加remote地址 git remote add githubOrigin git@github.com:sjtfreaks/blog.git 项目同步到Github上 git push -u githubOrigin main 分别同步github与gitlab即可 git push -u githubOrigin main git push -u origin main ","date":"2021-12-27","objectID":"/gitrsync/:0:0","tags":["gitlab"],"title":"gitlab与github同步项目","uri":"/gitrsync/"},{"categories":["基础"],"content":"iptables 基础知识 内核包过滤与NAT管理工具.是linux系统中在用户空间中运行的运来配置内核防火墙的工具。它可以设置，维护和检查linux内核中的ipv4包过滤规则和管理网络地址转换（NAT）。 ipatbles命令仅支持ipv4，如果使用的IP协议是ipv6则需要使用专门的管理工具ip6tables。 ","date":"2021-12-27","objectID":"/iptable/:0:0","tags":["运维"],"title":"iptables 基础知识","uri":"/iptable/"},{"categories":["基础"],"content":"常用参数 参数 作用 -t\u003c表\u003e 指定要操纵的表 -A 向规则链中追加条目 -D 从规则链中删除条目 -I 向规则链中插入条目 -R 替换规则链中的相应条目 -L 显示规则链中的已有条目 -F 清除规则链中的现有条目。不改变规则链的默认目标策略 -Z 清空规则链中的数据包计数器和字节计数器 -N 创建新的用户自定义规则链 -P 定义规则链中的默认目标（策略） -h 显示帮助信息 -p\u003c协议\u003e 指定要匹配的数据包的协议类型 -s\u003c源地址\u003e 指定要匹配的数据包的源IP地址 -j\u003c目标\u003e 指定要跳转的目标 -i\u003c网络接口\u003e 指定数据包进入本机的网络接口 -o\u003c网络接口\u003e 指定数据包离开本机做使用的网络接口 -c\u003c包计数\u003e 在执行插入、追加和替换操作时初始化包计数器和字节计数器 ","date":"2021-12-27","objectID":"/iptable/:1:0","tags":["运维"],"title":"iptables 基础知识","uri":"/iptable/"},{"categories":["基础"],"content":"参考实例 显示内核当前的filter表： iptables -L 显示内核当前的nat表： iptables -L -t nat 禁止本机对192.168.20.20地址的访问： iptables -t filter -A OUTPUT -d 192.168.20.20 -j DROP 显示filter表的OUTPUT链： iptables -L OUTPUT -t filter ","date":"2021-12-27","objectID":"/iptable/:2:0","tags":["运维"],"title":"iptables 基础知识","uri":"/iptable/"},{"categories":["k8s"],"content":"k3s 升级版本 ","date":"2021-12-27","objectID":"/k3supgrade/:0:0","tags":["k3s"],"title":"k3s 升级版本","uri":"/k3supgrade/"},{"categories":["k8s"],"content":"停止所有的 K3s 容器（慎用） 从 server 节点运行 killall 脚本 /usr/local/bin/k3s-killall.sh ","date":"2021-12-27","objectID":"/k3supgrade/:1:0","tags":["k3s"],"title":"k3s 升级版本","uri":"/k3supgrade/"},{"categories":["k8s"],"content":"开始升级 使用安装脚本升级 K3s curl -sfL https://get.k3s.io | sh - #国内可用 curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - 重启k3s sudo systemctl restart k3s ","date":"2021-12-27","objectID":"/k3supgrade/:2:0","tags":["k3s"],"title":"k3s 升级版本","uri":"/k3supgrade/"},{"categories":["日常"],"content":"安装配置 Terraform ","date":"2021-12-27","objectID":"/terraform/:0:0","tags":["Terraform"],"title":"安装配置 Terraform","uri":"/terraform/"},{"categories":["日常"],"content":"安装 macOS 苹果系统安装 #安装 brew tap hashicorp/tap brew install hashicorp/tap/terraform # 更新 brew update brew upgrade hashicorp/tap/terraform #验证安装 terraform -help windows 系统安装 #安装 choco install terraform #直接到这个url里下载64位系统 https://www.terraform.io/downloads #验证安装 terraform -help Linux 安装 curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - sudo apt-add-repository \"deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs)main\" sudo apt-get update \u0026\u0026 sudo apt-get install terraform #验证安装 terraform -help ","date":"2021-12-27","objectID":"/terraform/:1:0","tags":["Terraform"],"title":"安装配置 Terraform","uri":"/terraform/"},{"categories":["日常"],"content":"terrafrom 控制proxmox虚拟机 来源：https://github.com/Telmate/terraform-provider-proxmox ","date":"2021-12-27","objectID":"/terraform/:2:0","tags":["Terraform"],"title":"安装配置 Terraform","uri":"/terraform/"},{"categories":["日常"],"content":"首先你要有一台pve主机 安装过程本篇文章就不想了，主要是要写一下关于他的配置 https://pve.proxmox.com/pve-docs/ 下载 wget https://github.com/Telmate/terraform-provider-proxmox/releases/download/v2.9.3/terraform-provider-proxmox_2.9.3_linux_amd64.zip unzip terraform-provider-proxmox_2.9.3_linux_amd64.zip ","date":"2021-12-27","objectID":"/terraform/:2:1","tags":["Terraform"],"title":"安装配置 Terraform","uri":"/terraform/"},{"categories":["日常"],"content":"编写terrafrom程序 虚拟机main.tf terraform { required_version = \"\u003e= 0.14\" required_providers { proxmox = { source = \"telmate/proxmox\" } } } provider \"proxmox\" { # 配置选项 pm_tls_insecure = true pm_api_url = \"https://localhost:8006/api2/json\" pm_user = \"root@pam\" pm_password = \"passwd\" pm_otp = \"\" } # 创建VM resource \"proxmox_vm_qemu\" \"cloudinit-test\" { name = \"terraform-test-vm\" desc = \"A test for using terraform and cloudinit\" #节点名称必须与集群内的名称相同 #这可能不包括 FQDN target_node = \"pve\" #新虚拟机的目标资源池 pool = \"pool0\" #从中克隆这个虚拟机的模板名称 clone = \"node0\" #为这个虚拟机激活 QEMU 代理 agent = 1 os_type = \"cloud-init\" cores = 2 sockets = 1 vcpus = 0 cpu = \"host\" memory = 2048 scsihw = \"lsi\" #设置磁盘 disk { size = 32 type = \"virtio\" storage = \"local-lvm\" storage_type = \"lvmthin\" iothread = 1 ssd = 1 discard = \"on\" } #设置网络接口并分配一个 vlan 标签：256 network { model = \"virtio\" bridge = \"vmbr0\" tag = 256 } } 运行terrafrom # 初始化 terraform init # 查看产生的变更 terraform plan # 运行 terraform apply ","date":"2021-12-27","objectID":"/terraform/:2:2","tags":["Terraform"],"title":"安装配置 Terraform","uri":"/terraform/"},{"categories":["日常"],"content":"配置 配置这个terraform我们这个需要持续更新，首先我们先配置Azure吧 ","date":"2021-12-27","objectID":"/terraform/:3:0","tags":["Terraform"],"title":"安装配置 Terraform","uri":"/terraform/"},{"categories":["日常"],"content":"Azure 配置 安装azurecli # linux curl -L https://aka.ms/InstallAzureCli | bash apt install azure-cli # macOS brew update \u0026\u0026 brew install azure-cli 登录azure # 中国区azure az cloud set --name AzureCloud az login -u \u003c账户\u003e -p \u003c密码\u003e #海外azure az cloud set --name AzureChinaCloud az login -u \u003c账户\u003e -p \u003c密码\u003e 创建terrafrom代码 创建main.tf # 正在使用的 Azure 提供程序源和版本 terraform { required_version = \"\u003e=0.12\" required_providers { azurerm = { source = \"hashicorp/azurerm\" version = \"~\u003e2.0\" } } }# 配置 Microsoft Azure 提供程序 provider \"azurerm\" { features {} }# 资源组前缀 resource \"random_pet\" \"rg-name\" { prefix = var.resource_group_name_prefix }# 创建资源组 resource \"azurerm_resource_group\" \"rg\" { name = random_pet.rg-name.id location = var.resource_group_location } 创建variable.tf variable \"resource_group_name_prefix\" { default = \"rg\" description = \"Prefix of the resource group name that's combined with a random ID so name is unique in your Azure subscription.\" } variable \"resource_group_location\" { default = \"eastus\" description = \"Location of the resource group.\" } ","date":"2021-12-27","objectID":"/terraform/:3:1","tags":["Terraform"],"title":"安装配置 Terraform","uri":"/terraform/"},{"categories":["美食"],"content":"孜然杏鲍菇-素食 ","date":"2021-12-26","objectID":"/eryngii/:0:0","tags":["美食"],"title":"孜然杏鲍菇-素食","uri":"/eryngii/"},{"categories":["美食"],"content":"准备食材 杏鲍菇 蒜 糖 白芝麻 孜然粉 老抽 生抽 蚝油 ","date":"2021-12-26","objectID":"/eryngii/:1:0","tags":["美食"],"title":"孜然杏鲍菇-素食","uri":"/eryngii/"},{"categories":["美食"],"content":"步骤 杏鲍菇切片 蒜切成末 热油下蒜爆香 杏鲍菇下锅把水分炒干 加一勺生抽、半勺老抽，半勺蚝油，一勺孜然粉，一勺白芝麻，半勺糖炒匀 ","date":"2021-12-26","objectID":"/eryngii/:2:0","tags":["美食"],"title":"孜然杏鲍菇-素食","uri":"/eryngii/"},{"categories":["gitlab"],"content":"Argo cd 安装和部署 Argo CD 是一个为 Kubernetes 而生的，遵循声明式 GitOps 理念的持续部署（CD）工具。Argo CD 可在 Git 存储库更改时自动同步和部署应用程序 ","date":"2021-12-24","objectID":"/argocd/:0:0","tags":["gitlab"],"title":"Argo cd 安装和部署","uri":"/argocd/"},{"categories":["gitlab"],"content":"安装 k8s快速安装 k3s kubectl create namespace argocd k3s kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml ","date":"2021-12-24","objectID":"/argocd/:1:0","tags":["gitlab"],"title":"Argo cd 安装和部署","uri":"/argocd/"},{"categories":["gitlab"],"content":"使用 ","date":"2021-12-24","objectID":"/argocd/:2:0","tags":["gitlab"],"title":"Argo cd 安装和部署","uri":"/argocd/"},{"categories":["数据库"],"content":"mysql数据库备份迁移 使用mydumper做数据备份迁移 ","date":"2021-12-24","objectID":"/mysqldump/:0:0","tags":["mysql"],"title":"mysql数据库备份迁移","uri":"/mysqldump/"},{"categories":["数据库"],"content":"备份数据库 安装 # 安装 centos yum install https://github.com/mydumper/mydumper/releases/download/v0.11.5/mydumper-0.11.5-1.el7.x86_64.rpm yum install https://github.com/mydumper/mydumper/releases/download/v0.11.5/mydumper-0.11.5-1.el8.x86_64.rpm # 安装 ubuntu apt-get install libatomic1 wget https://github.com/mydumper/mydumper/releases/download/v0.11.5/mydumper_0.11.5-1.$(lsb_release -cs)_amd64.deb dpkg -i mydumper_0.11.5-1.$(lsb_release -cs)_amd64.deb 备份 nohup mydumper -h '备份数据库' \\ -u '用户名' \\ -p '密码' \\ --threads=16 \\ -B 备份数据库 \\ -v 3 \\ --outputdir=./backup --rows=100000 \\ -L mydumper-logs.log \u0026 ","date":"2021-12-24","objectID":"/mysqldump/:1:0","tags":["mysql"],"title":"mysql数据库备份迁移","uri":"/mysqldump/"},{"categories":["数据库"],"content":"迁移数据库 还原数据 nohup myloader -h '迁移数据库' \\ -u '用户名' \\ -p '密码' \\ --directory=./backup \\ -s 来源数据库 \\ -B 还原数据库 \\ -t 16 \\ -v 3 \\ -e 2\u003emyloader-logs.log \u0026 ","date":"2021-12-24","objectID":"/mysqldump/:2:0","tags":["mysql"],"title":"mysql数据库备份迁移","uri":"/mysqldump/"},{"categories":["数据库"],"content":"mydumper/myloader 参数 mydumper Usage: mydumper [OPTION...] multi-threaded MySQL dumping Help Options: -?, --help Show help options Application Options: -B, --database 需要备份的数据库，一个数据库一条命令备份，要不就是备份所有数据库，包括mysql。 -T, --tables-list 需要备份的表，用逗号分隔。 -o, --outputdir 备份文件目录 -s, --statement-size 生成插入语句的字节数，默认1000000，这个参数不能太小，不然会报 Row bigger than statement_size for tools.t_serverinfo -r, --rows 试图用行块来分割表，该参数关闭--chunk-filesize -F, --chunk-filesize 行块分割表的文件大小，单位是MB -c, --compress 压缩输出文件 -e, --build-empty-files 即使表没有数据，也产生一个空文件 -x, --regex 正则表达式匹配，如'db.table' -i, --ignore-engines 忽略的存储引擎，用逗号分隔 -m, --no-schemas 不导出表结构 -d, --no-data 不导出表数据 -G, --triggers 导出触发器 -E, --events 导出事件 -R, --routines 导出存储过程 -k, --no-locks 不执行共享读锁 警告：这将导致不一致的备份 --less-locking 减到最小的锁在innodb表上. -l, --long-query-guard 设置长查询时间,默认60秒，超过该时间则会报错：There are queries in PROCESSLIST running longer than 60s, aborting dump -K, --kill-long-queries kill掉长时间执行的查询，备份报错：Lock wait timeout exceeded; try restarting transaction -D, --daemon 启用守护进程模式 -I, --snapshot-interval dump快照间隔时间，默认60s，需要在daemon模式下 -L, --logfile 使用日志文件，默认标准输出到终端 --tz-utc 备份的时候允许备份Timestamp，这样会导致不同时区的备份还原会出问题，默认关闭，参数：--skip-tz-utc to disable. --skip-tz-utc --use-savepoints 使用savepoints来减少采集metadata所造成的锁时间，需要SUPER权限 --success-on-1146 Not increment error count and Warning instead of Critical in case of table doesn't exist --lock-all-tables 锁全表，代替FLUSH TABLE WITH READ LOCK -U, --updated-since Use Update_time to dump only tables updated in the last U days --trx-consistency-only Transactional consistency only -h, --host The host to connect to -u, --user Username with privileges to run the dump -p, --password User password -P, --port TCP/IP port to connect to -S, --socket UNIX domain socket file to use for connection -t, --threads 备份执行的线程数,默认4个线程 -C, --compress-protocol 在mysql连接上使用压缩协议 -V, --version Show the program version and exit -v, --verbose 更多输出, 0 = silent, 1 = errors, 2 = warnings, 3 = info, default 2 myloader Usage: myloader [OPTION...] multi-threaded MySQL loader Help Options: -?, --help Show help options Application Options: -d, --directory 备份文件所在的目录 -q, --queries-per-transaction 每个事务的query数量, 默认1000 -o, --overwrite-tables 如果表存在则先删除，使用该参数，需要备份时候要备份表结构，不然还原会找不到表 -B, --database 指定需要还原的数据库 -s, --source-db 还原的数据库 -e, --enable-binlog 启用二进制日志恢复数据 -h, --host The host to connect to -u, --user Username with privileges to run the dump -p, --password User password -P, --port TCP/IP port to connect to -S, --socket UNIX domain socket file to use for connection -t, --threads 使用的线程数量，默认4 -C, --compress-protocol 连接上使用压缩协议 -V, --version Show the program version and exit -v, --verbose 更多输出, 0 = silent, 1 = errors, 2 = warnings, 3 = info, default 2 ","date":"2021-12-24","objectID":"/mysqldump/:3:0","tags":["mysql"],"title":"mysql数据库备份迁移","uri":"/mysqldump/"},{"categories":["web 服务器"],"content":"nginx 编译参数详解 nginx编译参数 作用 –prefix= 指向安装目录 –sbin-path 指向（执行）程序文件（nginx） –conf-path= 指向配置文件（nginx.conf） –error-log-path= 指向错误日志目录 –pid-path= 指向 pid 文件（nginx.pid） –lock-path= 指向 lock 文件（nginx.lock）（安装文件锁定，防止安装文件被别人利用，或自己误操作。） –user= 指定程序运行时的非特权用户 –group= 指定程序运行时的非特权用户组 –builddir= 指向编译目录 –with-rtsig_module 启用 rtsig 模块支持（实时信号） –with-select_module 启用 select 模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：–withoutselect_module –with-poll_module 启用 poll 模块支持（功能与 select 相同，与 select 特性相同，为一种轮询模式,不推荐在高载环境下使用） –with-file-aio 启用 file aio 支持（一种 APL 文件传输格式） –with-ipv6 启用 ipv6 支持 –with-http_ssl_module 启用 ngx_http_ssl_module 支持（使支持 https 请求，需已安装 openssl） –with-http_realip_module 启用 ngx_http_realip_module 支持（这个模块允许从请求标头更改客户端的 IP 地址值，默认为关） –with-http_addition_module 启用 ngx_http_addition_module 支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求） –with-http_xslt_module 启用 ngx_http_xslt_module 支持（过滤转换 XML 请求 –with-http_image_filter_module 启用 ngx_http_image_filter_module 支持（传输 JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd 库要用到） –with-http_geoip_module 启用 ngx_http_geoip_module 支持（该模块创建基于与 MaxMind GeoIP 二进制文件相配的客户端 IP 地址的 ngx_http_geoip_module 变量） –with-http_sub_module 启用 ngx_http_sub_module 支持（允许用一些其他文本替换 nginx 响应中的一些文本） –with-http_dav_module 启用 ngx_http_dav_module 支持（增加 PUT,DELETE,MKCOL：创建集合,COPY 和 MOVE 方法）默认情况下为关闭，需编译开启 –with-http_flv_module 启用 ngx_http_flv_module 支持（提供寻求内存使用基于时间的偏移量文件） –with-http_gzip_static_module 启用 ngx_http_gzip_static_module 支持（在线实时压缩输出数据流） –with-http_random_index_module 启用 ngx_http_random_index_module 支持（从目录中随机挑选一个目录索引） –with-http_secure_link_module 启用 ngx_http_secure_link_module 支持（计算和检查要求所需的安全链接网址） –with-http_degradation_module 启用 ngx_http_degradation_module 支持（允许在内存不足的情况下返回204 或 444 码） –with-http_stub_status_module 启用 ngx_http_stub_status_module 支持（获取 nginx 自上次启动以来的工作状态） –without-http_charset_module 禁用 ngx_http_charset_module 支持（重新编码 web 页面，但只能是一个方向–服务器端到客户端，并且只有一个字节的编码可以被重新编码） –without-http_gzip_module 禁用 ngx_http_gzip_module 支持（该模块同-with-http_gzip_static_module 功能一样） –without-http_ssi_module 禁用 ngx_http_ssi_module 支持（该模块提供了一个在输入端处理处理服务器包含文件（SSI）的过滤器，目前支持 SSI 命令的列表是不完整的） –without-http_userid_module 禁用 ngx_http_userid_module 支持（该模块用来处理用来确定客户端后续请求的 cookies） –without-http_access_module 禁用 ngx_http_access_module 支持（该模块提供了一个简单的基于主机的访问控制。允许/拒绝基于 ip 地址） –without-http_auth_basic_module 禁用 ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http 基本认证方法来保护你的站点或其部分内容） –without-http_autoindex_module 禁用 disable ngx_http_autoindex_module 支持（该模块用于自动生成目录列表，只在 ngx_http_index_module 模块未找到索引文件时发出请求。） –without-http_geo_module 禁用 ngx_http_geo_module 支持（创建一些变量，其值依赖于客户端的 IP 地址） –without-http_map_module 禁用 ngx_http_map_module 支持（使用任意的键/值对设置配置变量） –without-http_split_clients_module 禁用 ngx_http_split_clients_module 支持（该模块用来基于某些条件划分用户。条件如：ip 地址、报头、cookies 等等） –without-http_referer_module 禁用 disable ngx_http_referer_module 支持（该模块用来过滤请求，拒绝报 头中 Referer 值不正确的请求） –without-http_rewrite_module 禁用 ngx_http_rewrite_module 支持（该模块允许使用正则表达式改变 URI，并且根据变量来转向以及选择配置。如果在 server 级别设置该选项，那么他们将在 location 之前生效。如果在location 还有更进一步的重写规则，location 部分的规则依然会被执行。如果这个 URI 重写是因为 location 部分的规则造成的，那么 location 部分会再次被执行作为新的 URI。 这个循环会执行 10 次，然后 Nginx 会返回一个 500 错误。） –without-http_proxy_module 禁用 ngx_http_proxy_module 支持（有关代理服务器） –without-http_fastcgi_module 禁用 ngx_http_fastcgi_module 支持（该模块允许 Nginx 与 FastCGI 进程交互，并通过传递参数来控制 FastCGI 进程工作。 ）FastCGI 一个常驻型的公共网关接口。 –without-http_uwsgi_module 禁用 ngx_http_uwsgi_module 支持（该模块用来医用 uwsgi 协议，uWSGI 服务器相关） –without-http_scgi_module 禁用 ngx_http_scgi_module 支持（该模块用来启用 SCGI 协议支持，SCGI 协议是CGI 协议的替代。它是一种应用程序与 HTTP 服务接口标准。它有些像 FastCGI 但他的设计 更容易实现。） –without-http_memcached_module 禁用 ngx_http_memcached_module 支持（该模块用来提供简单的缓存，以提高系统效率） -without-http_limit_zone_module 禁用 ngx_http_limit_zone_module 支持（该模块可以针对条件，进行会话的并发连接数控制） –without-http_limit_req_module 禁用 ngx_http_limit_req_module 支持（该模块允许你对于一个地址进行请求数量的限制用一个给定的 session 或一个特定的事件） –without-http_empty_gif_module 禁用 ngx_http_empty_gif_module 支持（该模块在内存中常驻了一个 1*1 的透明 GIF 图像，可以被非常快速的调用） –without-http_browser_module 禁用 ngx_http_browser_module 支持（该模块用来创建依赖于请求报头的值。如果浏览器为 modern ，","date":"2021-12-24","objectID":"/nginx02/:0:0","tags":["nginx","linux"],"title":"nginx 编译参数详解","uri":"/nginx02/"},{"categories":["web 服务器"],"content":"nginx 重写规则 rewrite模块 ","date":"2021-12-24","objectID":"/nginx04/:0:0","tags":["nginx","linux"],"title":"nginx 重写规则 rewrite模块","uri":"/nginx04/"},{"categories":["web 服务器"],"content":"语法 语法 默认值 使用字段 作用 break none server, location, if 完成当前设置的重写规则，停止执行其他的重写规则。 set variable value none server, location, if 为给定的变量设置一个特定值。 return code none server, location, if 停止处理并为客户端返回状态码。非标准的 444 状态码将关闭连接，不发送任何响应头。可以使用的状态码有：204，400，402-406，408，410, 411, 413, 416 与 500-504。如果状态码附带文字段落，该文本将被放置在响应主体。相反，如果状态码后面是一个 URL，该 URL 将成为 location 头补值。没有状态码的 URL 将被视为一个 302状态码。 rewrite_log on rewrite_log off server, location, if 启用时将在 error log 中记录 notice 级别的重写日志。 rewrite regex replacement flag none server, location, if 按照相关的正则表达式与字符串修改 URI，指令按照在配置文件中出现的顺序执行。可以在重写指令后面添加标记。注意：如果替换的字符串以 http://开头，请求将被重定向，并且不再执行多余的 rewrite 指令。尾部的标记(flag)可以是以下的值：last – 停止处理重写模块指令，之后搜索 location 与更改后的 URI 匹配.break – 完成重写指令。redirect – 返回 302 临时重定向，如果替换字段用 http://开头则被使用。permanent – 返回 301 永久重定向。 if (condition) { … } none server, location 尽量考虑使用 trp_files 代替。判断的条件可以有以下值 一个变量的名称：空字符传”“或者一些“0”开始的字符串为 false。 字符串比较：使用=或!=运算符 正则表达式匹配：使用~(区分大小写)和~(不区分大小写)，取反运算!~和!~。 文件是否存在：使用-f 和!-f 操作符 目录是否存在：使用-d 和!-d 操作符 文件、目录、符号链接是否存在：使用-e 和!-e 操作符 文件是否可执行：使用-x 和!-x 操作符'| ","date":"2021-12-24","objectID":"/nginx04/:1:0","tags":["nginx","linux"],"title":"nginx 重写规则 rewrite模块","uri":"/nginx04/"},{"categories":["web 服务器"],"content":"rewrite 重写规则 正则表达式 ","date":"2021-12-24","objectID":"/nginx04/:2:0","tags":["nginx","linux"],"title":"nginx 重写规则 rewrite模块","uri":"/nginx04/"},{"categories":["web 服务器"],"content":"nginx.conf 配置文件详解 # vim nginx.conf user nobody nobody; # 运行 nginx 的所属组和所有者 worker_processes 2; # 开启两个 nginx 工作进程,一般几个 CPU 核心就写几 error_log logs/error.log notice; # 错误日志路径 pid logs/nginx.pid; # pid 路径 events { worker_connections 1024; # 一个进程能同时处理 1024 个请求 } http { include mime.types; default_type application/octet-stream; log_format main ‘$remote_addr – $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘ ‘”$http_user_agent” “$http_x_forwarded_for”‘; access_log logs/access.log main; # 默认访问日志路径 sendfile on; keepalive_timeout 65; # keepalive 超市时间 # 开始配置一个域名,一个 server 配置段一般对应一个域名 server { listen 80; # # 在本机所有 ip 上监听 80,也可以写为 192.168.1.202:80,这样的话,就只监听 192.168.1.202 上的 80 口 server_name www.nbtyfood.com; # 域名 root /www/html/www.nbtyfood.com; # 站点根目录（程序目录） index index.html index.htm; # 索引文件 location / { # 可以有多个 location root /www/html/www.nbtyfood.com; # 站点根目录（程序目录） } error_page 500 502 503 504 /50x.html; # 定义错误页面,如果是 500 错误,则把站点根目录下的 50x.html 返回给用户 location = /50x.html { root /www/html/www.nbtyfood.com; } } # 开始配置站点 bbs.nbtyfood.com server { listen 80; server_name bbs.nbtyfood.com; root /www/html/bbs.nbtyfood.com; index index.html index.htm; # 索引文件 location / { root /www/html/bbs.nbtyfood.com; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /www/html/bbs.nbtyfood.com; } } } ","date":"2021-12-24","objectID":"/nginx03/:0:0","tags":["nginx","linux"],"title":"nginx.conf 配置文件详解","uri":"/nginx03/"},{"categories":["基础"],"content":"网络基础知识 ","date":"2021-12-23","objectID":"/network/:0:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"1、简述ISO/OSI七层模型的分层与作用 分层 作用 应用层 应用系统，提供用户服务 例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3 表示层 把数据转换为能与接收者的系统格式兼容并适合传输的格式，数据表示，加密，压缩 会话层 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。确定数据是否需要进行网络传递 分流网络传递还是本地保存 传输层 对数据分组，对报文进行分组(发送时)、组装(接收时)提供传输协议的选择：TCP (传输控制协议) :可靠的，面向连接的传输协议 (可靠，准确) (慢)UDP (用户数据报协议) :不可靠的，面向无连接的传输协议 (快) (不可靠)。端口封装，差错校验，滑动窗口，留空 网络层 网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。1.IP地址编址2.路由选择3.静态路由4.动态路由 数据链路层 数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。1.MAC地址编址2.MAC地址寻址3.差错校验 物理层 物理层（Physical Layer）在局域网上发送数据帧（Data Frame）1.数据实际传输2.电气特性定义 ","date":"2021-12-23","objectID":"/network/:1:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"2、TCP/IP四层模型与作用？ 分层 协议 应用层 HTTP、HTTPS、FTP、Telnet、SSH、SMTP、DNS 传输层 TCP、UDP 网络层 ICMP、IGMP、IP、ARP、RARP 数据链路层、物理层 PPP、PPPOE ","date":"2021-12-23","objectID":"/network/:2:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"3、TCP协议与UDP协议工作在哪一层，作用是什么？ 传输层，对报文进行分组(发送时)、组装(接收时)提供 当进程需要传输可靠的数据时应使用TCP，当进程需要高效传输数据，可以忽略可靠性时应使用UDP协议。 ","date":"2021-12-23","objectID":"/network/:3:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"4、简述TCP三次握手的过程。 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 ","date":"2021-12-23","objectID":"/network/:4:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"5、简述TCP包头的内容。 源端口和目的端口：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址 序号/序列号（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。初始序号称为 Init Sequense Number, ISN（序号/序列号这个字段很重要，大家留个印象，下文会详细讲解） 例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。 确认号 ack：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。 数据偏移（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。 保留：占 6 位，应置为 0，保留为今后使用。 标志位： 标志位 作用 URG 紧急指针（urgent pointer）有效。 ACK 确认序号有效 PSH 接收方应该尽快将这个报文交给应用层。 RST 重置连接。 SYN 发起一个新连接。 FIN 释放一个连接。 不要将确认序号Ack与标志位中的ACK搞混了。 确认方Ack=发起方Req+1，两端配对。 ","date":"2021-12-23","objectID":"/network/:5:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"6、简述TCP四次挥手的过程。 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 ","date":"2021-12-23","objectID":"/network/:6:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"7、172.22.141.231/26，该IP位于哪个网段？该网段拥有多少可用IP地址？广播地址是什么？ A类IP 10.1.1.1 标准子网掩码: 255.0.0.0 子网掩码二进制: 1111111.00000000.00000000.00000000 IP地址前8位是网络地址,后24位是主机地址 10.0.0.0-10.255.255.255 B类IP 172.16.1.1 标准子网掩码: 255.255.0.0 子网掩码二进制: 1111111.11111111.00000000.00000000 IP地址前16位是网络地址,后16位是主机地址 172.16.0.0-172.31.255.255 C类IP 192.168.1.1 标准子网掩码: 255.255.255.0 子网掩码二进制: 11111111.1111111.11111111.00000000 IP地址前24位是网络地址，后8位是主机地址 192.168.0.0-192.168.255.255 ","date":"2021-12-23","objectID":"/network/:7:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"8、简述IP地址的分类。 A类：（1.0.0.0-126.0.0.0）（默认子网掩码：255.0.0.0或 0xFF000000） 第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。 一般用于大型网络。 B类：（128.1.0.0-191.255.0.0）（默认子网掩码：255.255.0.0或0xFFFF0000） 前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。 一般用于中等规模网络。 C类：（192.0.1.0-223.255.255.0）（子网掩码：255.255.255.0或 0xFFFFFF00 前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。 一般用于小型网络。 D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1] 。 E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。 ","date":"2021-12-23","objectID":"/network/:8:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["基础"],"content":"9、简述私有IP地址的作用。 在全球范围内不具有唯一性，因此不能唯一标识一台联网的计算机。无需担心私有IP地址在全球范围内的冲突问题。 私有IP地址的路由信息不能对外发布，外部的IP数据包无法路由到私有IP地址的计算机上。 IP数据包中的源地址和目的地址是私有IP地址的, 不能在Internet上的路由器间进行存储转发的操作。 ","date":"2021-12-23","objectID":"/network/:9:0","tags":["运维"],"title":"网络基础知识","uri":"/network/"},{"categories":["docker"],"content":"docker 安装kong 网关 ","date":"2021-12-22","objectID":"/docker-kong/:0:0","tags":["docker"],"title":"docker 安装kong 网关","uri":"/docker-kong/"},{"categories":["docker"],"content":"建立数据库 创建网络 docker network create kong-net 建立数据库 docker run -d --name kong-database \\ --network=kong-net \\ -p 5432:5432 \\ -e \"POSTGRES_USER=kong\" \\ -e \"POSTGRES_DB=kong\" \\ -e \"POSTGRES_PASSWORD=kong123\" \\ postgres:9.6 创建kong数据 docker run --rm --network=kong-net \\ -e \"KONG_DATABASE=postgres\" \\ -e \"KONG_PG_HOST=kong-database\" \\ -e \"KONG_PG_PASSWORD=kong123\" \\ -e \"KONG_PASSWORD=kong123\" \\ kong:latest kong migrations bootstrap ","date":"2021-12-22","objectID":"/docker-kong/:1:0","tags":["docker"],"title":"docker 安装kong 网关","uri":"/docker-kong/"},{"categories":["docker"],"content":"创建 kong 创建kong gateway docker run -d --name kong \\ --network=kong-net \\ -e \"KONG_DATABASE=postgres\" \\ -e \"KONG_PG_HOST=kong-database\" \\ -e \"KONG_PG_USER=kong\" \\ -e \"KONG_PG_PASSWORD=kong123\" \\ -e \"KONG_CASSANDRA_CONTACT_POINTS=kong-database\" \\ -e \"KONG_PROXY_ACCESS_LOG=/dev/stdout\" \\ -e \"KONG_ADMIN_ACCESS_LOG=/dev/stdout\" \\ -e \"KONG_PROXY_ERROR_LOG=/dev/stderr\" \\ -e \"KONG_ADMIN_ERROR_LOG=/dev/stderr\" \\ -e \"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl\" \\ -p 8000:8000 \\ -p 8443:8443 \\ -p 127.0.0.1:8001:8001 \\ -p 127.0.0.1:8444:8444 \\ kong:latest ","date":"2021-12-22","objectID":"/docker-kong/:2:0","tags":["docker"],"title":"docker 安装kong 网关","uri":"/docker-kong/"},{"categories":["docker"],"content":"安装konga docker pull pantsel/konga:latest docker run --rm pantsel/konga:latest \\ -c prepare \\ -a postgres \\ -u postgresql://kong:kong123@172.18.0.1:5432/konga docker run -d -p 1337:1337 \\ --network kong-net \\ --name konga \\ -e \"NODE_ENV=production\" \\ -e \"DB_ADAPTER=postgres\" \\ -e \"DB_URI=postgresql://kong:kong123@172.18.0.1:5432/konga\" \\ pantsel/konga ","date":"2021-12-22","objectID":"/docker-kong/:3:0","tags":["docker"],"title":"docker 安装kong 网关","uri":"/docker-kong/"},{"categories":["docker"],"content":"搭建docker registry 镜像仓库 ","date":"2021-12-22","objectID":"/docker-registry/:0:0","tags":["docker"],"title":"搭建docker registry 镜像仓库","uri":"/docker-registry/"},{"categories":["docker"],"content":"获取镜像 docker pull registry:2.7.1 docker pull hyper/docker-registry-web ","date":"2021-12-22","objectID":"/docker-registry/:1:0","tags":["docker"],"title":"搭建docker registry 镜像仓库","uri":"/docker-registry/"},{"categories":["docker"],"content":"容器运行 mkdir -p /opt/data/registry docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry --name registry registry:2.7.1 docker run -d -p 8080:8080 --name registry-web --link registry \\ -e REGISTRY_URL=http://192.168.99.146:5000/v2 \\ -e REGISTRY_TRUST_ANY_SSL=true \\ -e REGISTRY_BASIC_AUTH=\"GjhYGDGi2HhkJB\" \\ -e REGISTRY_NAME=192.168.99.146:5000 \\ hyper/docker-registry-web ","date":"2021-12-22","objectID":"/docker-registry/:2:0","tags":["docker"],"title":"搭建docker registry 镜像仓库","uri":"/docker-registry/"},{"categories":["docker"],"content":"上传容器 vim /etc/docker/daemon.json { \"insecure-registries\": [\"192.168.99.146:5000\"] } docker tag sjtfreaks/hogo-nginx:v1.1 192.168.99.146:5000/sjtfreaks/hogo-nginx:v1.1 docker push 192.168.99.146:5000/sjtfreaks/hogo-nginx:v1.1 ","date":"2021-12-22","objectID":"/docker-registry/:3:0","tags":["docker"],"title":"搭建docker registry 镜像仓库","uri":"/docker-registry/"},{"categories":["日常"],"content":"rsync 文件同步 rsync 是一个常用的Linux应用程序，用于文件同步 ","date":"2021-12-20","objectID":"/rsync/:0:0","tags":["daliy","rsync"],"title":"rsync 文件同步","uri":"/rsync/"},{"categories":["日常"],"content":"安装 # Debian or Ubuntu $ sudo apt-get install rsync # Red Hat $ sudo yum install rsync # Arch Linux $ sudo pacman -S rsync ","date":"2021-12-20","objectID":"/rsync/:1:0","tags":["daliy","rsync"],"title":"rsync 文件同步","uri":"/rsync/"},{"categories":["日常"],"content":"基本用法 使用 rsync 命令时，可以作为cp和mv命令的替代方法，将源目录同步到目标目录。 -r 表示递归，即包含子目录。注意，-r是必须的，否则 rsync 运行不会成功。source目录表示源目录，destination表示目标目录。 -a 参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新 rsync -r source destination 远程同步 rsync -av \u003c源地址\u003e/ \u003c用户名\u003e@\u003cip地址\u003e:/\u003c目标地址\u003e 友情地址：mysql迁移 ","date":"2021-12-20","objectID":"/rsync/:2:0","tags":["daliy","rsync"],"title":"rsync 文件同步","uri":"/rsync/"},{"categories":["k8s"],"content":"helm 安装 ","date":"2021-12-16","objectID":"/helm/:0:0","tags":["k8s"],"title":"helm 安装","uri":"/helm/"},{"categories":["k8s"],"content":"脚本安装 curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 chmod 700 get_helm.sh ./get_helm.sh #或者可以使用这个命令 curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash helm help ","date":"2021-12-16","objectID":"/helm/:1:0","tags":["k8s"],"title":"helm 安装","uri":"/helm/"},{"categories":["k8s"],"content":"二进制安装 wget https://get.helm.sh/helm-v3.7.2-linux-amd64.tar.gz tar -zxvf helm-v3.7.2-linux-amd64.tar.gz cd helm-v3.7.2-linux-amd64 mv linux-amd64/helm /usr/local/bin/helm helm help ","date":"2021-12-16","objectID":"/helm/:2:0","tags":["k8s"],"title":"helm 安装","uri":"/helm/"},{"categories":["k8s"],"content":"k8s 部署loki日志 ","date":"2021-12-16","objectID":"/k8sloki/:0:0","tags":["k8s"],"title":"k8s 部署loki日志","uri":"/k8sloki/"},{"categories":["k8s"],"content":"helm 拉取loki #加源 helm repo add grafana https://grafana.github.io/helm-charts helm repo update #拉取 helm fetch grafana/loki-stack --untar --untardir . cd loki-stack # 生成 k8s 配置 helm template loki . \u003e loki.yaml # 部署（如果要修改默认配置必须要修改一下yaml） k3s kubectl apply -f loki.yaml ","date":"2021-12-16","objectID":"/k8sloki/:1:0","tags":["k8s"],"title":"k8s 部署loki日志","uri":"/k8sloki/"},{"categories":["日常"],"content":"自动判断跳转不同网站 根据用户目前的浏览器配置语言进行显示 供语言切换按钮，用户自定义选择不同的语言显示 根据识别用户的浏览器语言，自动判断并跳转到相应的语言网页，让你的网站更加灵动。 以下需要将代码放在 HTML 的内即可，然后自行制作多语言页面。 代码如下： \u003cscript type=\"text/javascript\"\u003e //获取用户语言的顺序是 //1.获取本地缓存里的内容 //2.用户浏览器的语言设置 //如果上面2个都没有获取到，就直接使用'en'作为用户选择的语言 var language = localStorage.getItem('locale') || window.navigator.language.toLowerCase() || 'en' //把用户的语言写入缓存，供下次获取使用 localStorage.setItem('locale', language) //判断用户的语言，跳转到不同的地方 if (language.indexOf(\"zh-\") !== -1) { window.location = '/zh-cn/index.html' } else if (language.indexOf('en') !== -1) { window.location = '/en/index.html' } else { //其它的都使用英文 window.location = '/en/index.html' } \u003c/script\u003e 核心代码 其实核心代码就是利用 navigator 的 language 属性 navigator.language ","date":"2021-12-16","objectID":"/auto/:0:0","tags":["javascript"],"title":"获取用户浏览器默认语言设置，自动判断跳转不同网站","uri":"/auto/"},{"categories":["日常"],"content":"第二种解决方案 可以通过获取用户的 IP，然后把 IP 放到 IP 库里查询所在地，从而加载对应的资源，这样的方案回更加准确！有的第三方会直接返回所在国家的编码，比如 cn / en 等就更好了 但是这样的方案也有一个弊端：如果用户通过科学上网，全局模式下，会被认为属于美国 / 日本等等（看梯子的 IP 而定了），那么会导致访问非常慢；但是这种偏差，很多翻墙的人都是了解的，没人会故意用美国的 IP 访问国内的淘宝 / 百度等网站的，除非是忘记切换回来了； IP 判断 市场上有很多 IP 判断的，拿 IP 倒是非常好做的一件事；比如我现在可以拿到用户访问本网站时候的 IP； ","date":"2021-12-16","objectID":"/auto/:1:0","tags":["javascript"],"title":"获取用户浏览器默认语言设置，自动判断跳转不同网站","uri":"/auto/"},{"categories":["基础"],"content":"linux服务基础知识 ","date":"2021-12-15","objectID":"/service/:0:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"1、哪些设置能够提升SSH远程管理的安全等级 ","date":"2021-12-15","objectID":"/service/:1:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"2、ssh连接时认证时间过长如何解决？ ","date":"2021-12-15","objectID":"/service/:2:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"3、scp和rsync进行远程文件复制有什么区别？ ","date":"2021-12-15","objectID":"/service/:3:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"4、请描述通过DHCP服务器获取IP地址的过程。 ","date":"2021-12-15","objectID":"/service/:4:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"5、简单描述FTP的主动模式和被动模式的区别？ ","date":"2021-12-15","objectID":"/service/:5:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"6、集群环境中，如何保证所有服务器之间的时间误差较小。 ","date":"2021-12-15","objectID":"/service/:6:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"7、请描述用户访问网站时DNS的解析过程。 ","date":"2021-12-15","objectID":"/service/:7:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"8、解释权威DNS和递归DNS的含义，并描述智能DNS的实现原理。 ","date":"2021-12-15","objectID":"/service/:8:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"9、公司里有一台服务器，需要在上面跑两个网站，并且其中一个网站需要更换新域名，请问如何处理？ 网站1：www.a.com 网站2：www.b.com（旧） www.d.com（新） 10、简述Apache的三种工作模式？ 11、请写出工作中常见的Apache优化策略。 12、有哪些技术可以提高网站的安全和效率？ 13、Apache和Nginx各有什么优缺点，应该如何选择？ 14、为什么Nginx的并发能力强，资源消耗低？ 15、写出几个Nginx的常用模块，并描述其功能。 16、请解释Nginx是如何连接PHP进行页面解析的？ 17、请描述Nginx和Tomcat之间的数据传输过程？ 18、请写出几个常见的HTTP状态码，并解释出现原因。 ","date":"2021-12-15","objectID":"/service/:9:0","tags":["运维"],"title":"linux服务基础知识","uri":"/service/"},{"categories":["基础"],"content":"mysql基础知识 ","date":"2021-12-15","objectID":"/mysql/:0:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"1、库表student.report,有3个字段，姓名、学科、成绩，记录如下，根据要求完成SQL语句： Name Subject Result 李白 Math 95 张三 English 83 王五 Math 79 李六 Math 85 张二 English 74 查询姓李的同学的个数。 查询表中数学成绩大于80的前2名同学的名字，并按分数从大到小的顺序排列。 ","date":"2021-12-15","objectID":"/mysql/:1:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"2、MYSQL集群一主多从，主库宕机，如何合理切换到从库，其它从库如何处理？ ","date":"2021-12-15","objectID":"/mysql/:2:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"3、单台MySQL达到性能瓶颈时，如何击碎性能瓶颈？ ","date":"2021-12-15","objectID":"/mysql/:3:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"4、MySQL什么时候创建索引？ ","date":"2021-12-15","objectID":"/mysql/:4:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"5、误操作drop语句导致数据库数据破坏，请给出恢复的实际大体步骤。 ","date":"2021-12-15","objectID":"/mysql/:5:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"6、如何保证Redis能永久保存数据？ ","date":"2021-12-15","objectID":"/mysql/:6:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"7、如何利用Redis对MySQL进行性能优化？ ","date":"2021-12-15","objectID":"/mysql/:7:0","tags":["运维"],"title":"mysql基础知识","uri":"/mysql/"},{"categories":["基础"],"content":"shell基础知识 ","date":"2021-12-15","objectID":"/shell/:0:0","tags":["运维"],"title":"shell基础知识","uri":"/shell/"},{"categories":["基础"],"content":"1、有一个b.txt文本(内容如下)，要求将所有域名截取出来，并统计重复域名出现的次数： http://www.baidu.com/index.html https://www.atguigu.com/index.html http://www.sina.com.cn/1024.html https://www.atguigu.com/2048.html http://www.sina.com.cn/4096.html https://www.atguigu.com/8192.html ","date":"2021-12-15","objectID":"/shell/:1:0","tags":["运维"],"title":"shell基础知识","uri":"/shell/"},{"categories":["基础"],"content":"2、统计当前服务器正在连接的IP地址，并按连接次数排序 ","date":"2021-12-15","objectID":"/shell/:2:0","tags":["运维"],"title":"shell基础知识","uri":"/shell/"},{"categories":["基础"],"content":"3、使用循环在/atguigu目录下创建10个txt文件，要求文件名称由6位随机小写字母加固定字符串（_gg）组成，例如：pzjebg_gg.txt。 ","date":"2021-12-15","objectID":"/shell/:3:0","tags":["运维"],"title":"shell基础知识","uri":"/shell/"},{"categories":["基础"],"content":"4、生成随机数字。 ","date":"2021-12-15","objectID":"/shell/:4:0","tags":["运维"],"title":"shell基础知识","uri":"/shell/"},{"categories":["基础"],"content":"5、批量检查多个网站是否可以正常访问，要求使用shell数组实现，检测策略尽量模拟用户真实访问模式。 http://www.atguigu.com http://www.gulixueyuan.com http://www.baidu.com ","date":"2021-12-15","objectID":"/shell/:5:0","tags":["运维"],"title":"shell基础知识","uri":"/shell/"},{"categories":["k8s"],"content":"Kubernetes 创建nfs存储类 首先你需要在别的终端上创建nfs服务并能提供nfs访问 Kubernetes 不包含内部 NFS 驱动。你需要使用外部驱动为 NFS 创建 StorageClass。 https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner 安装nfs驱动 ","date":"2021-12-13","objectID":"/k8snfs/:0:0","tags":["k8s"],"title":"Kubernetes 创建nfs存储类","uri":"/k8snfs/"},{"categories":["k8s"],"content":"安装nfs驱动 #安装nfs客户端 apt-get install nfs-common git clone https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner.git cd nfs-subdir-external-provisioner/deploy k3s kubectl create -f rbac.yaml vim deployment.yaml 编辑 deployment.yaml apiVersion:apps/v1kind:Deploymentmetadata:name:nfs-client-provisionerlabels:app:nfs-client-provisioner# replace with namespace where provisioner is deployednamespace:defaultspec:replicas:1strategy:type:Recreateselector:matchLabels:app:nfs-client-provisionertemplate:metadata:labels:app:nfs-client-provisionerspec:serviceAccountName:nfs-client-provisionercontainers:- name:nfs-client-provisionerimage:k8s.gcr.io/sig-storage/nfs-subdir-external-provisioner:v4.0.2volumeMounts:- name:nfs-client-rootmountPath:/persistentvolumesenv:- name:PROVISIONER_NAMEvalue:k8s-sigs.io/nfs-subdir-external-provisioner- name:NFS_SERVERvalue:192.168.99.235- name:NFS_PATHvalue:/volume2/nfs-k8svolumes:- name:nfs-client-rootnfs:server:192.168.99.235path:/volume2/nfs-k8s 定义存储类 k3s kubectl create -f deployment.yaml k3s kubectl create -f class.yaml ","date":"2021-12-13","objectID":"/k8snfs/:1:0","tags":["k8s"],"title":"Kubernetes 创建nfs存储类","uri":"/k8snfs/"},{"categories":["k8s"],"content":"测试存储是否正常 k3s kubectl create -f test-claim.yaml -f test-pod.yaml k3s kubectl delete -f test-claim.yaml -f test-pod.yaml ","date":"2021-12-13","objectID":"/k8snfs/:2:0","tags":["k8s"],"title":"Kubernetes 创建nfs存储类","uri":"/k8snfs/"},{"categories":["k8s"],"content":"创建有状态pods（mysql） 创建mysql-deployment.yaml apiVersion:v1kind:Servicemetadata:name:mysqlspec:ports:- port:3306targetPort:3306selector:app:mysqlclusterIP:Nonetype:LoadBalancer---apiVersion:apps/v1kind:Deploymentmetadata:name:mysqlspec:selector:matchLabels:app:mysqlstrategy:type:Recreatetemplate:metadata:labels:app:mysqlspec:containers:- image:mysql:5.7name:mysqlenv:# Use secret in real usage- name:MYSQL_ROOT_PASSWORDvalue:passwordports:- containerPort:3306name:mysqlvolumeMounts:- name:mysql-persistent-storagemountPath:/var/lib/mysqlvolumes:- name:mysql-persistent-storagepersistentVolumeClaim:claimName:mysql-pv-claim 创建mysql-pv.yaml apiVersion:v1kind:PersistentVolumemetadata:name:mysql-pv-volumespec:storageClassName:managed-nfs-storagecapacity:storage:20GiaccessModes:- ReadWriteOncenfs:server:192.168.99.235path:\"/volume2/nfs-k8s\"---apiVersion:v1kind:PersistentVolumeClaimmetadata:name:mysql-pv-claimspec:storageClassName:managed-nfs-storageaccessModes:- ReadWriteManyresources:requests:storage:20Gi ","date":"2021-12-13","objectID":"/k8snfs/:3:0","tags":["k8s"],"title":"Kubernetes 创建nfs存储类","uri":"/k8snfs/"},{"categories":["k8s"],"content":"部署 mysql k3s kubectl apply -f mysql-pv.yamlk3s kubectl apply -f mysql-deployment.yamlk3s kubectl describe deployment mysql ","date":"2021-12-13","objectID":"/k8snfs/:4:0","tags":["k8s"],"title":"Kubernetes 创建nfs存储类","uri":"/k8snfs/"},{"categories":["web 服务器"],"content":"nginx 日志配置 ","date":"2021-12-13","objectID":"/nginx01/:0:0","tags":["nginx","linux"],"title":"nginx 日志格式整理","uri":"/nginx01/"},{"categories":["web 服务器"],"content":"语法 access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; # 设置访问日志 access_log off; # 关闭访问日志 例子： access_log /var/logs/nginx-access.log access_log /var/logs/nginx-access.log buffer=32k gzip flush=1m ","date":"2021-12-13","objectID":"/nginx01/:1:0","tags":["nginx","linux"],"title":"nginx 日志格式整理","uri":"/nginx01/"},{"categories":["web 服务器"],"content":"使用log_format 自定义日志格式 Nginx预定义了名为combined日志格式，如果没有明确指定日志格式默认使用该格式： log_format combined '$remote_addr - $remote_user [$time_local] ' '\"$request\" $status $body_bytes_sent ' '\"$http_referer\" \"$http_user_agent\"'; 如果不想使用Nginx预定义的格式，可以通过log_format指令来自定义。 ","date":"2021-12-13","objectID":"/nginx01/:2:0","tags":["nginx","linux"],"title":"nginx 日志格式整理","uri":"/nginx01/"},{"categories":["web 服务器"],"content":"语法 log_format name [escape=default|json] string ...; 变量 含义 $bytes_sent 发送给客户端的总字节数 $body_bytes_sent 发送给客户端的字节数，不包括响应头的大小 $connection 连接序列号 $connection_requests 当前通过连接发出的请求数量 $msec 日志写入时间，单位为秒，精度是毫秒 $pipe 如果请求是通过http流水线发送，则其值为\"p\"，否则为“.\" $request_length 请求长度（包括请求行，请求头和请求体） $request_time 请求处理时长，单位为秒，精度为毫秒，从读入客户端的第一个字节开始，直到把最后一个字符发送张客户端进行日志写入为止 $status 响应状态码 $time_iso8601 标准格式的本地时间,形如“2017-05-24T18:31:27+08:00” $time_local 通用日志格式下的本地时间，如\"24/May/2017:18:31:27 +0800\" $http_referer 请求的referer地址。 $http_user_agent 客户端浏览器信息。 $remote_addr 客户端IP $http_x_forwarded_for 当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的x_forwarded_for设置。 $request 完整的原始请求行，如 “GET / HTTP/1.1” $remote_user 客户端用户名称，针对启用了用户认证的请求 $request_uri 完整的请求地址，如 “https://daojia.com/\" 例子： access_log /var/logs/nginx-access.log main log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; ","date":"2021-12-13","objectID":"/nginx01/:2:1","tags":["nginx","linux"],"title":"nginx 日志格式整理","uri":"/nginx01/"},{"categories":["日常"],"content":"linux系统开启root权限 修改ssh服务配置文件 sudo su - sudo vim /etc/ssh/sshd_config 增加权限 在# Authentication: 下输入 PermitRootLogin yes 更改root密码，重启服务 sudo passwd root service sshd restart ","date":"2021-12-12","objectID":"/resetsystem/:0:0","tags":["linux"],"title":"linux系统开启root权限","uri":"/resetsystem/"},{"categories":["数据库"],"content":"mysql 学习笔记（1） 本文章不涉及到关于mysql开放上的问题，主要记录关于mysql出现的问题，以及如何去维护mysql数据的日常。 ","date":"2021-12-12","objectID":"/mysql01/:0:0","tags":["mysql"],"title":"mysql 笔记（1）","uri":"/mysql01/"},{"categories":["数据库"],"content":"mysql各类信息的收集 收集变量信息 showglobalvariables; 收集进程信息 showPROCESSLIST; 收集错误日志 showglobalvariableslike'log_error'; 收集慢日志信息 showglobalvariableslike'slow_querry_log_file'; 收集锁信息，高峰时期运行三次，每次间隔10s SELECTlocked_table,locked_index,locked_type,blocking_pid,T2.USERblocking_user,T2.HOSTblocking_host,blocking_lock_mode,blocking_trx_rows_modified,waiting_pid,T3.USERwaiting_user,T3.HOSTwaiting_host,waiting_lock_mode,waiting_trx_row_modified,wait_age_secs,waiting_queryFROMsys.x$innodb_lock_waitsT1LEFTJOININFROMATION_SCHEMA.processlistT2ONT1.blocking_pid=T2.IDLEFTJOININFROMATION_SCHEMA.processlistT3ONT3.ID=T1.waiting_pid; 收集mysql状态信息 showglobalstatus;showengineinnodbstatus;showengineinnodbmutex; ","date":"2021-12-12","objectID":"/mysql01/:1:0","tags":["mysql"],"title":"mysql 笔记（1）","uri":"/mysql01/"},{"categories":["数据库"],"content":"mysql 基础语法 连接数据库 mysql-u\u003c用户名\u003e-p 创建数据库 CREATEDATABASE\u003c数据库名称\u003e; 删除数据库 dropdatabase\u003c数据库名称\u003e; 选择数据库 use\u003c数据库名称\u003e; 创建表 CREATEtable\u003c数据表名\u003e(\u003c字段名1\u003e\u003c数据类型\u003e[约束条件],\u003c字段名2\u003e\u003c数据类型\u003e[约束条件],\u003c字段名3\u003e\u003c数据类型\u003e[约束条件])#例如CREATETABLEIFNOTEXISTS`nbtyfood_tbl`(`nbtyfood_id`INTUNSIGNEDAUTO_INCREMENT,`nbtyfood_title`VARCHAR(100)NOTNULL,`nbtyfood_author`VARCHAR(40)NOTNULL,`submission_date`DATE,PRIMARYKEY(`nbtyfood_id`))ENGINE=InnoDBDEFAULTCHARSET=utf8; 删除表 DROPTABLE\u003c数据表名\u003e; 插入数据 INSERTINTOtable_name(field1,field2,...fieldN)VALUESvalue1,value2,...valueN); 更新数据 UPDATE\u003c数据表名\u003eSET\u003c字段名1\u003e='更新'WHERE\u003c字段名2\u003e=3; 删除数据 DELETEFROM\u003c数据表名\u003eWHERE\u003c字段名2\u003e=3; 查询数据 select*from\u003c数据表名\u003e; ","date":"2021-12-12","objectID":"/mysql01/:2:0","tags":["mysql"],"title":"mysql 笔记（1）","uri":"/mysql01/"},{"categories":["日常"],"content":"163企业邮箱设置教程 请进入这个网站 https://qiye.163.com/help/l-11.html ","date":"2021-12-10","objectID":"/qyyemail163/:0:0","tags":["daliy"],"title":"163企业邮箱设置教程","uri":"/qyyemail163/"},{"categories":["gitlab"],"content":"git技巧 Git 是一个 “分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过 “回撤” 这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用 “回撤” 是找不回来的。而 “版本管理工具” 能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。 下面的内容就是列举了常用的 Git 命令和一些小技巧，可以通过 “页面内查找” 的方式进行快速查询：Ctrl/Command+f。 ","date":"2021-12-10","objectID":"/gitlab/:0:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"开卷必读 如果之前未使用过 Git，可以学习 Git 小白教程入门 一定要先测试命令的效果后，再用于工作环境中，以防造成不能弥补的后果！到时候别拿着砍刀来找我 所有的命令都在git version 2.7.4 (Apple Git-66)下测试通过 统一概念： 工作区：改动（增删文件和内容） 暂存区：输入命令：git add 改动的文件名，此次改动就放到了 ‘暂存区’ 本地仓库(简称：本地)：输入命令：git commit 此次修改的描述，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。 远程仓库(简称：远程)：输入命令：git push 远程仓库，此次改动就放到了 ‘远程仓库’（GitHub 等) commit-id：输出命令：git log，最上面那行 commit xxxxxx，后面的字符串就是 commit-id 如果喜欢这个项目，欢迎 Star、提交 Pr、反馈问题😊 ","date":"2021-12-10","objectID":"/gitlab/:1:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"目录 脑图 展示帮助信息 回到远程仓库的状态 重设第一个commit 查看冲突文件列表 展示工作区和暂存区的不同 展示暂存区和最近版本的不同 展示暂存区、工作区和最近版本的不同 快速切换到上一个分支 删除已经合并到 master 的分支 展示本地分支关联远程仓库的情况 关联远程分支 列出所有远程分支 列出本地和远程分支 查看远程分支和本地分支的对应关系 远程删除了分支本地也想删除 创建并切换到本地分支 从远程分支中创建并切换到本地分支 删除本地分支 删除远程分支 重命名本地分支 查看标签 查看标签详细信息 本地创建标签 推送标签到远程仓库 删除本地标签 删除远程标签 切回到某个标签 放弃工作区的修改 恢复删除的文件 以新增一个 commit 的方式还原某一个 commit 的修改 回到某个 commit 的状态，并删除后面的 commit 修改上一个 commit 的描述 查看 commit 历史 显示本地更新过 HEAD 的 git 命令记录 修改作者名 修改远程仓库的 url 增加远程仓库 列出所有远程仓库 查看两个星期内的改动 把 A 分支的某一个 commit，放到 B 分支上 给 git 命令起别名 存储当前的修改，但不用提交 commit 保存当前状态，包括 untracked 的文件 展示所有 stashes 回到某个 stash 的状态 回到最后一个 stash 的状态，并删除这个 stash 删除所有的 stash 从 stash 中拿出某个文件的修改 展示所有 tracked 的文件 展示所有 untracked 的文件 展示所有忽略的文件 强制删除 untracked 的文件 强制删除 untracked 的目录 展示简化的 commit 历史 查看某段代码是谁写的 把某一个分支导出成一个文件 从包中导入分支 执行 rebase 之前自动 stash 从远程仓库根据 ID，拉下某一状态，到本地分支 详细展示一行中的修改 清除 .gitignore 文件中记录的文件 展示所有 alias 和 configs 展示忽略的文件 commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit 在 commit log 中显示 GPG 签名 删除全局设置 新建并切换到新分支上，同时这个分支没有任何 commit 展示任意分支某一文件的内容 clone 下来指定的单一分支 clone 最新一次提交 忽略某个文件的改动 忽略文件的权限变化 以最后提交的顺序列出所有 Git 分支 在 commit log 中查找相关内容 把暂存区的指定 file 放到工作区中 强制推送 git 配置 http 和 socks 代理 git 配置 ssh 代理 优雅的Commit信息 commit工具 声明 ","date":"2021-12-10","objectID":"/gitlab/:2:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示帮助信息 git help -g The command output as below: The common Git guides are: attributes Defining attributes per path cli Git command-line interface and conventions core-tutorial A Git core tutorial for developers cvs-migration Git for CVS users diffcore Tweaking diff output everyday A useful minimum set of commands for Everyday Git glossary A Git Glossary hooks Hooks used by Git ignore Specifies intentionally untracked files to ignore modules Defining submodule properties namespaces Git namespaces repository-layout Git Repository Layout revisions Specifying revisions and ranges for Git tutorial A tutorial introduction to Git tutorial-2 A tutorial introduction to Git: part two workflows An overview of recommended workflows with Git 'git help -a' and 'git help -g' list available subcommands and some concept guides. See 'git help \u003ccommand\u003e' or 'git help \u003cconcept\u003e' to read about a specific subcommand or concept. ","date":"2021-12-10","objectID":"/gitlab/:3:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"回到远程仓库的状态 抛弃本地所有的修改，回到远程仓库的状态。 git fetch --all \u0026\u0026 git reset --hard origin/master ","date":"2021-12-10","objectID":"/gitlab/:4:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"重设第一个 commit 也就是把所有的改动都重新放回工作区，并清空所有的 commit，这样就可以重新提交第一个 commit 了 git update-ref -d HEAD ","date":"2021-12-10","objectID":"/gitlab/:5:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"查看冲突文件列表 展示工作区的冲突文件列表 git diff --name-only --diff-filter=U ","date":"2021-12-10","objectID":"/gitlab/:6:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示工作区和暂存区的不同 输出工作区和暂存区的 different (不同)。 git diff 还可以展示本地仓库中任意两个 commit 之间的文件变动： git diff \u003ccommit-id\u003e \u003ccommit-id\u003e ","date":"2021-12-10","objectID":"/gitlab/:7:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示暂存区和最近版本的不同 输出暂存区和本地最近的版本 (commit) 的 different (不同)。 git diff --cached ","date":"2021-12-10","objectID":"/gitlab/:8:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示暂存区、工作区和最近版本的不同 输出工作区、暂存区 和本地最近的版本 (commit) 的 different (不同)。 git diff HEAD ","date":"2021-12-10","objectID":"/gitlab/:9:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"快速切换到上一个分支 git checkout - ","date":"2021-12-10","objectID":"/gitlab/:10:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"删除已经合并到 master 的分支 git branch --merged master | grep -v '^\\*\\| master' | xargs -n 1 git branch -d ","date":"2021-12-10","objectID":"/gitlab/:11:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示本地分支关联远程仓库的情况 git branch -vv ","date":"2021-12-10","objectID":"/gitlab/:12:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"关联远程分支 关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。 git branch -u origin/mybranch 或者在 push 时加上 -u 参数 git push origin/mybranch -u ","date":"2021-12-10","objectID":"/gitlab/:13:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"列出所有远程分支 -r 参数相当于：remote git branch -r ","date":"2021-12-10","objectID":"/gitlab/:14:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"列出本地和远程分支 -a 参数相当于：all git branch -a ","date":"2021-12-10","objectID":"/gitlab/:15:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"查看远程分支和本地分支的对应关系 git remote show origin ","date":"2021-12-10","objectID":"/gitlab/:16:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"远程删除了分支本地也想删除 git remote prune origin ","date":"2021-12-10","objectID":"/gitlab/:17:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"创建并切换到本地分支 git checkout -b \u003cbranch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:18:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"从远程分支中创建并切换到本地分支 git checkout -b \u003cbranch-name\u003e origin/\u003cbranch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:19:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"删除本地分支 git branch -d \u003clocal-branchname\u003e ","date":"2021-12-10","objectID":"/gitlab/:20:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"删除远程分支 git push origin --delete \u003cremote-branchname\u003e 或者 git push origin :\u003cremote-branchname\u003e ","date":"2021-12-10","objectID":"/gitlab/:21:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"重命名本地分支 git branch -m \u003cnew-branch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:22:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"查看标签 git tag 展示当前分支的最近的 tag git describe --tags --abbrev=0 ","date":"2021-12-10","objectID":"/gitlab/:23:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"查看标签详细信息 git tag -ln ","date":"2021-12-10","objectID":"/gitlab/:24:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"本地创建标签 git tag \u003cversion-number\u003e 默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag： $ git tag -a \u003cversion-number\u003e -m \"v1.0 发布(描述)\" \u003ccommit-id\u003e ","date":"2021-12-10","objectID":"/gitlab/:25:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"推送标签到远程仓库 首先要保证本地创建好了标签才可以推送标签到远程仓库： git push origin \u003clocal-version-number\u003e 一次性推送所有标签，同步到远程仓库： git push origin --tags ","date":"2021-12-10","objectID":"/gitlab/:26:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"删除本地标签 git tag -d \u003ctag-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:27:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"删除远程标签 git push origin --delete tag \u003ctagname\u003e ","date":"2021-12-10","objectID":"/gitlab/:28:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"切回到某个标签 一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态： git checkout -b branch_name tag_name ","date":"2021-12-10","objectID":"/gitlab/:29:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"放弃工作区的修改 git checkout \u003cfile-name\u003e 放弃所有修改： git checkout . ","date":"2021-12-10","objectID":"/gitlab/:30:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"恢复删除的文件 git rev-list -n 1 HEAD -- \u003cfile_path\u003e #得到 deleting_commit git checkout \u003cdeleting_commit\u003e^ -- \u003cfile_path\u003e #回到删除文件 deleting_commit 之前的状态 ","date":"2021-12-10","objectID":"/gitlab/:31:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"以新增一个 commit 的方式还原某一个 commit 的修改 git revert \u003ccommit-id\u003e ","date":"2021-12-10","objectID":"/gitlab/:32:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"回到某个 commit 的状态，并删除后面的 commit 和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit git reset \u003ccommit-id\u003e #默认就是-mixed参数。 git reset --mixed HEAD^ #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。 git reset --soft HEAD~3 #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可 git reset --hard \u003ccommit-id\u003e #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容 ","date":"2021-12-10","objectID":"/gitlab/:33:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"修改上一个 commit 的描述 如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit git commit --amend ","date":"2021-12-10","objectID":"/gitlab/:34:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"查看 commit 历史 git log ","date":"2021-12-10","objectID":"/gitlab/:35:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"查看某段代码是谁写的 blame 的意思为‘责怪’，你懂的。 git blame \u003cfile-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:36:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"显示本地更新过 HEAD 的 git 命令记录 每次更新了 HEAD 的 git 命令比如 commit、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。 这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。 git reflog ","date":"2021-12-10","objectID":"/gitlab/:37:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"修改作者名 git commit --amend --author='Author Name \u003cemail@address.com\u003e' ","date":"2021-12-10","objectID":"/gitlab/:38:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"修改远程仓库的 url git remote set-url origin \u003cURL\u003e ","date":"2021-12-10","objectID":"/gitlab/:39:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"增加远程仓库 git remote add origin \u003cremote-url\u003e ","date":"2021-12-10","objectID":"/gitlab/:40:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"列出所有远程仓库 git remote ","date":"2021-12-10","objectID":"/gitlab/:41:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"查看两个星期内的改动 git whatchanged --since='2 weeks ago' ","date":"2021-12-10","objectID":"/gitlab/:42:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"把 A 分支的某一个 commit，放到 B 分支上 这个过程需要 cherry-pick 命令，参考 git checkout \u003cbranch-name\u003e \u0026\u0026 git cherry-pick \u003ccommit-id\u003e ","date":"2021-12-10","objectID":"/gitlab/:43:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"给 git 命令起别名 简化命令 git config --global alias.\u003chandle\u003e \u003ccommand\u003e 比如：git status 改成 git st，这样可以简化命令 git config --global alias.st status ","date":"2021-12-10","objectID":"/gitlab/:44:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"存储当前的修改，但不用提交 commit 详解可以参考廖雪峰老师的 git 教程 git stash ","date":"2021-12-10","objectID":"/gitlab/:45:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"保存当前状态，包括 untracked 的文件 untracked 文件：新建的文件 git stash -u ","date":"2021-12-10","objectID":"/gitlab/:46:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示所有 stashes git stash list ","date":"2021-12-10","objectID":"/gitlab/:47:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"回到某个 stash 的状态 git stash apply \u003cstash@{n}\u003e ","date":"2021-12-10","objectID":"/gitlab/:48:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"回到最后一个 stash 的状态，并删除这个 stash git stash pop ","date":"2021-12-10","objectID":"/gitlab/:49:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"删除所有的 stash git stash clear ","date":"2021-12-10","objectID":"/gitlab/:50:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"从 stash 中拿出某个文件的修改 git checkout \u003cstash@{n}\u003e -- \u003cfile-path\u003e ","date":"2021-12-10","objectID":"/gitlab/:51:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示所有 tracked 的文件 git ls-files -t ","date":"2021-12-10","objectID":"/gitlab/:52:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示所有 untracked 的文件 git ls-files --others ","date":"2021-12-10","objectID":"/gitlab/:53:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示所有忽略的文件 git ls-files --others -i --exclude-standard ","date":"2021-12-10","objectID":"/gitlab/:54:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"强制删除 untracked 的文件 可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，注意两点： clean 后，删除的文件无法找回 不会影响 tracked 的文件的改动，只会删除 untracked 的文件 git clean \u003cfile-name\u003e -f ","date":"2021-12-10","objectID":"/gitlab/:55:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"强制删除 untracked 的目录 可以用来删除新建的目录，注意:这个命令也可以用来删除 untracked 的文件。详情见上一条 git clean \u003cdirectory-name\u003e -df ","date":"2021-12-10","objectID":"/gitlab/:56:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示简化的 commit 历史 git log --pretty=oneline --graph --decorate --all ","date":"2021-12-10","objectID":"/gitlab/:57:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"把某一个分支导出成一个文件 git bundle create \u003cfile\u003e \u003cbranch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:58:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"从包中导入分支 新建一个分支，分支内容就是上面 git bundle create 命令导出的内容 git clone repo.bundle \u003crepo-dir\u003e -b \u003cbranch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:59:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"执行 rebase 之前自动 stash git rebase --autostash ","date":"2021-12-10","objectID":"/gitlab/:60:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"从远程仓库根据 ID，拉下某一状态，到本地分支 git fetch origin pull/\u003cid\u003e/head:\u003cbranch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:61:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"详细展示一行中的修改 git diff --word-diff ","date":"2021-12-10","objectID":"/gitlab/:62:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"清除 gitignore 文件中记录的文件 git clean -X -f ","date":"2021-12-10","objectID":"/gitlab/:63:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示所有 alias 和 configs 注意： config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config git config --local --list (当前目录) git config --global --list (全局) ","date":"2021-12-10","objectID":"/gitlab/:64:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示忽略的文件 git status --ignored ","date":"2021-12-10","objectID":"/gitlab/:65:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit git log Branch1 ^Branch2 ","date":"2021-12-10","objectID":"/gitlab/:66:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"在 commit log 中显示 GPG 签名 git log --show-signature ","date":"2021-12-10","objectID":"/gitlab/:67:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"删除全局设置 git config --global --unset \u003centry-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:68:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"新建并切换到新分支上，同时这个分支没有任何 commit 相当于保存修改，但是重写 commit 历史 git checkout --orphan \u003cbranch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:69:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"展示任意分支某一文件的内容 git show \u003cbranch-name\u003e:\u003cfile-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:70:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"clone 下来指定的单一分支 git clone -b \u003cbranch-name\u003e --single-branch https://github.com/user/repo.git ","date":"2021-12-10","objectID":"/gitlab/:71:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"clone 最新一次提交 只会 clone 最近一次提交，将减少 clone 时间 git clone --depth=1 https://github.com/user/repo.git ","date":"2021-12-10","objectID":"/gitlab/:72:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"忽略某个文件的改动 关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动 git update-index --assume-unchanged path/to/file 恢复 track 指定文件的改动 git update-index --no-assume-unchanged path/to/file ","date":"2021-12-10","objectID":"/gitlab/:73:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"忽略文件的权限变化 不再将文件的权限变化视作改动 git config core.fileMode false ","date":"2021-12-10","objectID":"/gitlab/:74:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"以最后提交的顺序列出所有 Git 分支 最新的放在最上面 git for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/ ","date":"2021-12-10","objectID":"/gitlab/:75:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"在 commit log 中查找相关内容 通过 grep 查找，given-text：所需要查找的字段 git log --all --grep='\u003cgiven-text\u003e' ","date":"2021-12-10","objectID":"/gitlab/:76:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"把暂存区的指定 file 放到工作区中 不添加参数，默认是 -mixed git reset \u003cfile-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:77:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"强制推送 git push -f \u003cremote-name\u003e \u003cbranch-name\u003e ","date":"2021-12-10","objectID":"/gitlab/:78:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"git 配置 http 和 socks 代理 git config --global https.proxy 'http://127.0.0.1:8001' # 适用于 privoxy 将 socks 协议转为 http 协议的 http 端口 git config --global http.proxy 'http://127.0.0.1:8001' git config --global socks.proxy \"127.0.0.1:1080\" ","date":"2021-12-10","objectID":"/gitlab/:79:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"git 配置 ssh 代理 $ cat ~/.ssh/config Host gitlab.com ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p # 直接使用 shadowsocks 提供的 socks5 代理端口 Host github.com ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p ","date":"2021-12-10","objectID":"/gitlab/:80:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"脑图 ","date":"2021-12-10","objectID":"/gitlab/:81:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"优雅的Commit信息 使用Angular团队提交规范 主要有以下组成 标题行: 必填, 描述主要修改类型和内容 主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等 页脚注释: 放 Breaking Changes 或 Closed Issues 常用的修改项 type: commit 的类型 feat: 新特性 fix: 修改问题 refactor: 代码重构 docs: 文档修改 style: 代码格式修改, 注意不是 css 修改 test: 测试用例修改 chore: 其他修改, 比如构建流程, 依赖管理. scope: commit 影响的范围, 比如: route, component, utils, build… subject: commit 的概述 body: commit 具体修改内容, 可以分为多行 footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接. ","date":"2021-12-10","objectID":"/gitlab/:82:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["gitlab"],"content":"commit工具 可以使用cz-cli工具代替 git commit 全局安装 npm install -g commitizen cz-conventional-changelog echo '{ \"path\": \"cz-conventional-changelog\" }' \u003e ~/.czrc 全局安装后使用 git cz 代替 git commit就可以了,如下图 ⬆ 返回顶部 ","date":"2021-12-10","objectID":"/gitlab/:83:0","tags":["gitlab"],"title":"git技巧","uri":"/gitlab/"},{"categories":["docker"],"content":"docker image镜像上传 登入docker hub，在https://hub.docker.com上注册你的账号。 docker login username：#输入你的用户名 password：#输入你的密码 ","date":"2021-12-09","objectID":"/dockerimage/:0:0","tags":["docker"],"title":"docker image镜像上传","uri":"/dockerimage/"},{"categories":["docker"],"content":"上传镜像 docker tag nginx:hugo sjtfreaks/hogo-nginx:v1 docker push sjtfreaks/hogo-nginx:v1 ","date":"2021-12-09","objectID":"/dockerimage/:1:0","tags":["docker"],"title":"docker image镜像上传","uri":"/dockerimage/"},{"categories":["docker"],"content":"docker 进阶使用 dockerfile和docker compose的配置 Dockerfile 使用 Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 例子： FROM nginx RUN echo '这是一个本地构建的nginx镜像' \u003e /usr/share/nginx/html/index.html 保存Dockerfile文件并在本地路径执行 docker build -t nginx:v1-test . docker run -name docker run --name nginx-test -d -p 8080:80 nginx:v1-test 浏览nginx页面确认更新内容 curl 127.0.0.1:8080 输出： 这是一个本地构建的nginx镜像 ","date":"2021-12-09","objectID":"/docker01/:0:0","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["docker"],"content":"Docker命令详解 ","date":"2021-12-09","objectID":"/docker01/:1:0","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["docker"],"content":"COPY 复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] \u003c源路径1\u003e... \u003c目标路径\u003e COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [\"\u003c源路径1\u003e\",... \"\u003c目标路径\u003e\"] \u003c源路径\u003e：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如： COPY hom* /mydir/ COPY hom?.txt /mydir/ ","date":"2021-12-09","objectID":"/docker01/:1:1","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["docker"],"content":"FROM FROM：定制的镜像都是基于 FROM 的镜像 FROM nginx ","date":"2021-12-09","objectID":"/docker01/:1:2","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["docker"],"content":"RUN RUN：用于执行后面跟着的命令行命令 shell： RUN \u003c命令行命令\u003e # \u003c命令行命令\u003e 等同于，在终端操作的 shell 命令。 exec： RUN [\"可执行文件\", \"参数1\", \"参数2\"] # 例如： # RUN [\"./test.php\", \"dev\", \"offline\"] 等价于 RUN ./test.php dev offline ","date":"2021-12-09","objectID":"/docker01/:1:3","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["docker"],"content":"ADD ADD 指令和 COPY 的使用格类似 ADD 的优点：在执行 \u003c源文件\u003e 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 \u003c目标路径\u003e。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 ","date":"2021-12-09","objectID":"/docker01/:1:4","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["docker"],"content":"CMD 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: CMD 在docker run 时运行。 RUN 是在 docker build。 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 CMD \u003cshell 命令\u003e CMD [\"\u003c可执行文件或命令\u003e\",\"\u003cparam1\u003e\",\"\u003cparam2\u003e\",...] CMD [\"\u003cparam1\u003e\",\"\u003cparam2\u003e\",...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 ","date":"2021-12-09","objectID":"/docker01/:1:5","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["docker"],"content":"通过dockerfile文件封装hugo dokcerfile文件 FROM nginx:1.21 COPY public/ /usr/share/nginx/html docker.sh文件 #/!bin/bash echo \"删除旧的docker\" docker ps docker stop nginx-hugo docker rm nginx-hugo docker rmi nginx:hugo echo \"生成新的docker\" hugo -t LoveIt -D docker build -t nginx:hugo . docker run --name nginx-hugo -d -p 8080:80 nginx:hugo echo \"显示端口\" netstat -lntp 执行脚本： sh update.sh ","date":"2021-12-09","objectID":"/docker01/:2:0","tags":["docker","dockerfile","DockerCompose"],"title":"docker进阶使用","uri":"/docker01/"},{"categories":["k8s"],"content":"Kubernetes k8s 组件 ","date":"2021-12-09","objectID":"/kubernetes/:0:0","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"控制平面组件（Control Plane Components） 控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 replicas 字段时，启动新的 pod）。 ","date":"2021-12-09","objectID":"/kubernetes/:1:0","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"kube-apiserver API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。 ","date":"2021-12-09","objectID":"/kubernetes/:1:1","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。 ","date":"2021-12-09","objectID":"/kubernetes/:1:2","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"kube-scheduler 控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。 ","date":"2021-12-09","objectID":"/kubernetes/:1:3","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"kube-controller-manager 运行控制器进程的控制平面组件。 ","date":"2021-12-09","objectID":"/kubernetes/:1:4","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"cloud-controller-manager 云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。 ","date":"2021-12-09","objectID":"/kubernetes/:1:5","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"Node 组件 节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。 ","date":"2021-12-09","objectID":"/kubernetes/:2:0","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"kubelet 一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。 ","date":"2021-12-09","objectID":"/kubernetes/:2:1","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"kube-proxy kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。 ","date":"2021-12-09","objectID":"/kubernetes/:2:2","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["k8s"],"content":"容器运行时（Container Runtime） 容器运行环境是负责运行容器的软件。 Kubernetes 支持多个容器运行环境: Docker、 containerd、CRI-O 以及任何实现 Kubernetes CRI (容器运行环境接口)。 ","date":"2021-12-09","objectID":"/kubernetes/:2:3","tags":["k8s"],"title":"Kubernetes k8s 组件","uri":"/kubernetes/"},{"categories":["日常"],"content":"2021年第50周周记 这周完成了以下任务 搭建hugo博客 使用docker封装了blog 搭建k3s环境 计划： 学习k8s 总结：没啥好总结，刚开始写周记，就随便写一点吧 ","date":"2021-12-08","objectID":"/20211210/:0:0","tags":["daliy"],"title":"2021年第50周记","uri":"/20211210/"},{"categories":["web 服务器"],"content":"nginx 汇总 各类nginx 问题汇总 ","date":"2021-12-08","objectID":"/nginx/:0:0","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["web 服务器"],"content":"安装nginx #centos yum install nginx #ubuntu apt install nginx ","date":"2021-12-08","objectID":"/nginx/:1:0","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["web 服务器"],"content":"http代理 ","date":"2021-12-08","objectID":"/nginx/:2:0","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["web 服务器"],"content":"正向代理 server { listen 80; server_name www.nbtyfood.com; location / { proxy_pass http://127.0.0.1:8080; } } ","date":"2021-12-08","objectID":"/nginx/:2:1","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["web 服务器"],"content":"反向代理 ","date":"2021-12-08","objectID":"/nginx/:2:2","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["web 服务器"],"content":"负载均衡 upstream mysvr { server 192.168.10.121:3333; server 192.168.10.122:3333; } server { .... location ~*^.+$ { proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 } } 热备 如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB….. upstream mysvr { server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 } 轮询 nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB…. upstream mysvr { server 127.0.0.1:7878; server 192.168.10.121:3333; } 加权轮询 跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB…. upstream mysvr { server 127.0.0.1:7878 weight=1;w server 192.168.10.121:3333 weight=2; } ip_hash nginx会让相同的客户端ip请求相同的服务器。 upstream mysvr { server 127.0.0.1:7878; server 192.168.10.121:3333; ip_hash; } ","date":"2021-12-08","objectID":"/nginx/:3:0","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["web 服务器"],"content":"web缓存 location /images/ { proxy_cache my_cache; proxy_ignore_headers Cache-Control; proxy_cache_valid any 30m; # ... } ","date":"2021-12-08","objectID":"/nginx/:4:0","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["web 服务器"],"content":"重定向 rewrite ^/(.*) http://www.nbtyfood.com/$1 permanent; ","date":"2021-12-08","objectID":"/nginx/:5:0","tags":["nginx","linux"],"title":"nginx 汇总","uri":"/nginx/"},{"categories":["基础"],"content":"TCP/IP协议 ","date":"2021-12-08","objectID":"/tcpip/:0:0","tags":["TCP/IP"],"title":"TCP/IP详解","uri":"/tcpip/"},{"categories":["基础"],"content":"什么是TCP/IP协议 OSI七层架构 TCP/IP四层模型 协议 应用层 HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS 表示层 应用层 XDR、ASN.1、NCP、TLS、ASCII 会话层 sockets、SOCKS、PAP 传输层 传输层 TCP、UDP、RTP、SCTP 网络层 网络互连层 IP、ICMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP 数据链路层 网络访问（链接）层 以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11 物理层 调制解调器、无线电、光纤 ","date":"2021-12-08","objectID":"/tcpip/:1:0","tags":["TCP/IP"],"title":"TCP/IP详解","uri":"/tcpip/"},{"categories":["基础"],"content":"报文结构 TCP报文段首部格式 源端口和目的端口：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址 序号/序列号（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。初始序号称为 Init Sequense Number, ISN（序号/序列号这个字段很重要，大家留个印象，下文会详细讲解） 例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。 确认号 ack：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。 数据偏移（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。 保留：占 6 位，应置为 0，保留为今后使用。 ","date":"2021-12-08","objectID":"/tcpip/:1:1","tags":["TCP/IP"],"title":"TCP/IP详解","uri":"/tcpip/"},{"categories":["基础"],"content":"TCP三次握手 ","date":"2021-12-08","objectID":"/tcpip/:2:0","tags":["TCP/IP"],"title":"TCP/IP详解","uri":"/tcpip/"},{"categories":["基础"],"content":"TCP四次挥手 ","date":"2021-12-08","objectID":"/tcpip/:3:0","tags":["TCP/IP"],"title":"TCP/IP详解","uri":"/tcpip/"},{"categories":["基础"],"content":"TCP/IP其他问题 TCP与UDP的区别 （1）TCP：面向连接，可靠的，速度慢，效率低。 （2）UDP：无连接、不可靠、速度快、效率高。 当进程需要传输可靠的数据时应使用TCP，当进程需要高效传输数据，可以忽略可靠性时应使用UDP协议。 ","date":"2021-12-08","objectID":"/tcpip/:4:0","tags":["TCP/IP"],"title":"TCP/IP详解","uri":"/tcpip/"},{"categories":["日常"],"content":"内网穿透 文章中使用的内网穿透前提是必须具有公网IP的云服务器，不符合条件的同学可以跳过了。 ","date":"2021-12-08","objectID":"/nps/:0:0","tags":["内网穿透","nps"],"title":"自建服务器内网穿透","uri":"/nps/"},{"categories":["日常"],"content":"nps内网穿透 nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。 ","date":"2021-12-08","objectID":"/nps/:1:0","tags":["内网穿透","nps"],"title":"自建服务器内网穿透","uri":"/nps/"},{"categories":["日常"],"content":"在公网服务器上安装nps sever端 wget https://github.com/ehang-io/nps/releases/download/v0.26.10/linux_amd64_server.tar.gz tar -zxvf linux_amd64_server.tar.gz sudo ./nps install sudo nps start ","date":"2021-12-08","objectID":"/nps/:1:1","tags":["内网穿透","nps"],"title":"自建服务器内网穿透","uri":"/nps/"},{"categories":["日常"],"content":"在控制端安装npc client端 wget https://github.com/ehang-io/nps/releases/download/v0.26.10/linux_amd64_client.tar.gz tar -zxvf linux_amd64_client.tar.gz sudo ./npc -server=ip:port -vkey=web界面中显示的密钥 sudo npc start npc安装完成可以进入web页面穿透端口和域名 http://localhost:8080 ","date":"2021-12-08","objectID":"/nps/:1:2","tags":["内网穿透","nps"],"title":"自建服务器内网穿透","uri":"/nps/"},{"categories":["日常"],"content":"frps内网穿透 frps 相对于nps的劣势是有断流的风险 frps 相对于nps的优势是对于高流量的媒体服务能够提供更可靠的支持 ","date":"2021-12-08","objectID":"/nps/:2:0","tags":["内网穿透","nps"],"title":"自建服务器内网穿透","uri":"/nps/"},{"categories":["日常"],"content":"安装frps wget https://code.aliyun.com/MvsCode/frps-onekey/raw/master/install-frps.sh -O ./install-frps.sh chmod 700 ./install-frps.sh ./install-frps.sh install 卸载 frps服务 ./install-frps.sh uninstall 更新 frps服务 ./install-frps.sh update Server management（服务管理器） Usage: /etc/init.d/frps {start|stop|restart|status|config|version} ","date":"2021-12-08","objectID":"/nps/:2:1","tags":["内网穿透","nps"],"title":"自建服务器内网穿透","uri":"/nps/"},{"categories":["日常"],"content":"树莓派安装k3s ","date":"2021-12-06","objectID":"/rasberry/:0:0","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"1.安装k3s ","date":"2021-12-06","objectID":"/rasberry/:1:0","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"控制节点 curl -sfL https://get.k3s.io | sh - cat /var/lib/rancher/k3s/server/node-token ","date":"2021-12-06","objectID":"/rasberry/:1:1","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"工作节点 curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh - 树莓派特别要注意一个坑，就是关于内存的问题这个之后再讲 k3s kubectl get nodes #显示正确的节点表示完成 ","date":"2021-12-06","objectID":"/rasberry/:1:2","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"卸载 k3s #server 节点 /usr/local/bin/k3s-uninstall.sh #agent 节点 /usr/local/bin/k3s-agent-uninstall.sh ","date":"2021-12-06","objectID":"/rasberry/:1:3","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"2.安装dashboard k3s面板 ","date":"2021-12-06","objectID":"/rasberry/:2:0","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"部署 Kubernetes 仪表盘 GITHUB_URL=https://github.com/kubernetes/dashboard/releases VERSION_KUBE_DASHBOARD=$(curl -w '%{url_effective}' -I -L -s -S ${GITHUB_URL}/latest -o /dev/null | sed -e 's|.*/||') sudo k3s kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/${VERSION_KUBE_DASHBOARD}/aio/deploy/recommended.yaml ","date":"2021-12-06","objectID":"/rasberry/:2:1","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"仪表盘 RBAC 配置 创建以下资源清单文件： dashboard.admin-user.yml apiVersion:v1kind:ServiceAccountmetadata:name:admin-usernamespace:kubernetes-dashboard dashboard.admin-user-role.yml apiVersion:rbac.authorization.k8s.io/v1kind:ClusterRoleBindingmetadata:name:admin-userroleRef:apiGroup:rbac.authorization.k8s.iokind:ClusterRolename:cluster-adminsubjects:- kind:ServiceAccountname:admin-usernamespace:kubernetes-dashboard 部署admin-user 配置： sudo k3s kubectl create -f dashboard.admin-user.yml -f dashboard.admin-user-role.yml 获得 Bearer Token sudo k3s kubectl -n kubernetes-dashboard describe secret admin-user-token | grep '^token' 现在可以通过以下网址访问仪表盘： sudo k3s kubectl proxy http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ ","date":"2021-12-06","objectID":"/rasberry/:2:2","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"连接lens cat /etc/rancher/k3s/k3s.yaml 更改本地host 穿透服务器IP local ","date":"2021-12-06","objectID":"/rasberry/:2:3","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"3.安装 kube—prometheus 监控 ","date":"2021-12-06","objectID":"/rasberry/:3:0","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"一键安装 wget https://github.com/prometheus-operator/kube-prometheus/archive/refs/tags/v0.9.0.tar.gz tar -zxvf v0.9.0.tar.gz cd kube-prometheus-0.9.0/manifests k3s kubectl apply -f setup/ k3s kubectl get pod -n monitoring k3s kubectl apply -f . ","date":"2021-12-06","objectID":"/rasberry/:3:1","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"一键卸载 cd kube-prometheus/manifests k3s kubectl delete -f . k3s kubectl delete -f setup/ ","date":"2021-12-06","objectID":"/rasberry/:3:2","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"4.安装 nfs外部驱动挂载storageclass ","date":"2021-12-06","objectID":"/rasberry/:4:0","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["日常"],"content":"5.创建有状态pods（mysql） ","date":"2021-12-06","objectID":"/rasberry/:5:0","tags":["树莓派","k3s"],"title":"树莓派搭建k3s","uri":"/rasberry/"},{"categories":["Mac"],"content":"brew 安装配置 ","date":"2021-12-03","objectID":"/brew/:0:0","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"一.安装 ","date":"2021-12-03","objectID":"/brew/:1:0","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"1.在ubuntu上安装 brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ","date":"2021-12-03","objectID":"/brew/:1:1","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"2.在centos上安装 brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ","date":"2021-12-03","objectID":"/brew/:1:2","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"3.在MacOS上安装 brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ","date":"2021-12-03","objectID":"/brew/:1:3","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"二、使用 ","date":"2021-12-03","objectID":"/brew/:2:0","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"1.安装 wget brew install wget Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local $ cd /usr/local $ find Cellar Cellar/wget/1.16.1 Cellar/wget/1.16.1/bin/wget Cellar/wget/1.16.1/share/man/man1/wget.1 $ ls -l bin bin/wget -\u003e ../Cellar/wget/1.16.1/bin/wget ","date":"2021-12-03","objectID":"/brew/:2:1","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"2.创建你自己的 Homebrew 包 $ brew create https://foo.com/bar-1.0.tgz Created /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/bar.rb ","date":"2021-12-03","objectID":"/brew/:2:2","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["Mac"],"content":"3.撤销你的变更或与上游更新合并 $ brew edit wget # 使用 $EDITOR 编辑! ","date":"2021-12-03","objectID":"/brew/:2:3","tags":["brew"],"title":"brew 安装配置","uri":"/brew/"},{"categories":["gitlab"],"content":"gitlab CI/CD 的使用 我将使用gitlab的流水线自动实现hugo blog 文章的自动发布。 ","date":"2021-12-03","objectID":"/gitlab-cicd/:0:0","tags":["gitlab"],"title":"gitlab CI/CD 的使用","uri":"/gitlab-cicd/"},{"categories":["gitlab"],"content":"一、基础知识 ","date":"2021-12-03","objectID":"/gitlab-cicd/:1:0","tags":["gitlab"],"title":"gitlab CI/CD 的使用","uri":"/gitlab-cicd/"},{"categories":["gitlab"],"content":"二、安装过程 ","date":"2021-12-03","objectID":"/gitlab-cicd/:2:0","tags":["gitlab"],"title":"gitlab CI/CD 的使用","uri":"/gitlab-cicd/"},{"categories":["gitlab"],"content":"1.安装gitlab runner 首先需要安装 gitlab runner 进入服务器A 安装方法： 容器部署 手动二进制文件部署 通过rpm/deb包部署 docker方式安装 安装文档：https://docs.gitlab.com/runne… docker run -dit \\ --name gitlab-runner \\ --restart always \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner 1.1 设置信息 docker exec -it gitlab-runner gitlab-runner register 非docker方式安装 2.1 安装GitLab Runner 安装环境：Linux 其他环境参考：https://docs.gitlab.com/runne… 下载 curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 添加权限 chmod +x /usr/local/bin/gitlab-runner 新建gitlab-runner用户 sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash 安装 安装时需要指定我们上面新建的用户 gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner 启动 gitlab-runner start # Download the binary for your system sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 # Give it permissions to execute sudo chmod +x /usr/local/bin/gitlab-runner # Create a GitLab CI user sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash # Install and run as service sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner sudo gitlab-runner start ","date":"2021-12-03","objectID":"/gitlab-cicd/:2:1","tags":["gitlab"],"title":"gitlab CI/CD 的使用","uri":"/gitlab-cicd/"},{"categories":["gitlab"],"content":"2.配置 docker shell链接 ssh-keygen -t rsa cd .ssh/ cat id_rsa.pub \u003e\u003eauthorized_keys docker cp id_rsa gitlab-runner:/root docker exec -it gitlab-runner /bin/bash chmod 600 /root/id_rsa vim /etc/systemd/system/gitlab-runner.service \"--syslog\" \"--user\" \"root\" #修改为root wq保存退出 systemctl daemon-reload systemctl restart gitlab-runner ","date":"2021-12-03","objectID":"/gitlab-cicd/:2:2","tags":["gitlab"],"title":"gitlab CI/CD 的使用","uri":"/gitlab-cicd/"},{"categories":["gitlab"],"content":"3.配置.gitlab-ci.yml文件 vim .gitlab-ci.yml stages: - build - test - deploy build-job: stage: build script: - echo \"上传代码\" - echo \"上传完成.\" unit-test-job: stage: test script: - echo - sleep 60 - echo \"Code coverage is 90%\" lint-test-job: stage: test script: - echo \"Linting code... This will take about 10 seconds.\" - sleep 10 - echo \"No lint issues found.\" deploy-job: stage: deploy script: - echo \"Deploying application...\" - echo \"Application successfully deployed.\" ","date":"2021-12-03","objectID":"/gitlab-cicd/:2:3","tags":["gitlab"],"title":"gitlab CI/CD 的使用","uri":"/gitlab-cicd/"},{"categories":["gitlab"],"content":"git使用方法 ","date":"2021-12-03","objectID":"/git/:0:0","tags":["gitlab"],"title":"git使用方法","uri":"/git/"},{"categories":["gitlab"],"content":"一、git安装配置 Debian/Ubuntu apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev apt-get install git git --version git version 1.8.1.2 Centos/RedHat yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel yum -y install git-core git --version git version 1.7.1 ","date":"2021-12-03","objectID":"/git/:1:0","tags":["gitlab"],"title":"git使用方法","uri":"/git/"},{"categories":["gitlab"],"content":"Markdown教程 参考：https://www.runoob.com/markdown ","date":"2021-12-03","objectID":"/markdown/:0:0","tags":["Markdown"],"title":"Markdown教程","uri":"/markdown/"},{"categories":["hugo"],"content":"hugo命令大全 ","date":"2021-12-01","objectID":"/first/:0:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"安装hugo ","date":"2021-12-01","objectID":"/first/:1:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"二进制安装 brew install hugo ","date":"2021-12-01","objectID":"/first/:1:1","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"源码安装 export GOPATH=$HOME/go go get -v github.com/spf13/hugo go get -u -v github.com/spf13/hugo #更新依赖库 ","date":"2021-12-01","objectID":"/first/:1:2","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"生成站点 hugo new site /opt/blog cd /opt/blog ","date":"2021-12-01","objectID":"/first/:2:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"创建文章 hugo new about.md vim about.md hugo new post/first.md ","date":"2021-12-01","objectID":"/first/:3:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"安装皮肤 cd /opt/blog/themes git clone https://github.com/dillonzq/LoveIt.git ","date":"2021-12-01","objectID":"/first/:4:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"运行hugo hugo server -t LoveIt -D ","date":"2021-12-01","objectID":"/first/:5:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"部署 你要部署在github Page上 hugo --theme=hyde --baseUrl=\"http://coderzh.github.io/\" cd public $ git init $ git remote add origin https://github.com/coderzh/coderzh.github.io.git $ git add -A $ git commit -m \"first commit\" $ git push -u origin master ","date":"2021-12-01","objectID":"/first/:6:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"hugo 添加搜索插件 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-12-01","objectID":"/first/:7:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # LoveIt 新增 | 0.2.1 最大结果数目 maxResultLength = 10 # LoveIt 新增 | 0.2.3 结果内容片段长度 snippetLength = 50 # LoveIt 新增 | 0.2.1 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # LoveIt 新增 | 0.2.4 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" ","date":"2021-12-01","objectID":"/first/:7:1","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["hugo"],"content":"常用命令 nohup hugo server -e production -t LoveIt -D \u0026 ","date":"2021-12-01","objectID":"/first/:8:0","tags":["hugo"],"title":"hugo 命令大全","uri":"/first/"},{"categories":["基础"],"content":"运维图谱 ","date":"2021-12-01","objectID":"/yunwei/:0:0","tags":["运维"],"title":"运维知识图谱","uri":"/yunwei/"},{"categories":null,"content":"关于 苦逼打工人，IT互联网鄙视链底层运维 ","date":"2021-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"兴趣爱好： 游泳，干饭 ","date":"2021-01-01","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"最近看的书： 《薛兆丰经济学》《论持久战》 ","date":"2021-01-01","objectID":"/about/:2:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"微信： ","date":"2021-01-01","objectID":"/about/:3:0","tags":null,"title":"关于我","uri":"/about/"}]